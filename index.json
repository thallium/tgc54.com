[{"authors":null,"categories":null,"content":" Also known online as @Thallium54 Back End Developer intern @ IBM CS student @ York University Tech things that I enjoy: software development, home server, Linux… Competitive programming enthusiast Some of my other hobbies: Rubik’s cube, custom (ergonomic) mechanical keyboard, table tennis. Languages: C/C++, Python, Go, JS, Java, Lua ","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"Also known online as @Thallium54 Back End Developer intern @ IBM CS student @ York University Tech things that I enjoy: software development, home server, Linux… Competitive programming enthusiast Some of my other hobbies: Rubik’s cube, custom (ergonomic) mechanical keyboard, table tennis.","tags":null,"title":"Gengchen Tuo","type":"authors"},{"authors":null,"categories":null,"content":"","date":1636848e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1636848e3,"objectID":"fe2f41546cc94fa45b68377537542160","permalink":"thallium.github.io/tgc54.com/project/cp-parser/","publishdate":"2021-11-14T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/project/cp-parser/","section":"project","summary":"A command line application that parses sample test cases from various competitive programming websites with ease.","tags":null,"title":"Competitive Programming Parser","type":"project"},{"authors":null,"categories":null,"content":"","date":1647388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1647388800,"objectID":"846a6d9a8dbf496181714ada857357e8","permalink":"thallium.github.io/tgc54.com/project/mirai-cp/","publishdate":"2022-03-16T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/project/mirai-cp/","section":"project","summary":"A QQ bot centered around Competitive Programming. Inspired by TLE discord bot. \n \n Current feature: get upcoming contests, plot user's rating graph.","tags":null,"title":"Mirai-competitive-programming","type":"project"},{"authors":null,"categories":[],"content":"There is problem managing python version with your package manager. An easy solution is to use pyenv:\nInstall pyenv with your package manager. For MacOS, it’s brew install pyenv. Install desired python version: pyenv install \u0026lt;version\u0026gt; Set global python version pyenv global \u0026lt;version\u0026gt; Set up your shell environment for Pyenv, for zsh, add this to your .zshrc: export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34; command -v pyenv \u0026gt;/dev/null || export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34; eval \u0026#34;$(pyenv init -)\u0026#34; ","date":1658544335,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658544335,"objectID":"69807e372c83d163840d800fba09da6f","permalink":"thallium.github.io/tgc54.com/post/manage-python-with-pyenv/","publishdate":"2022-07-22T22:45:35-04:00","relpermalink":"thallium.github.io/tgc54.com/post/manage-python-with-pyenv/","section":"post","summary":"There is problem managing python version with your package manager. An easy solution is to use pyenv:\nInstall pyenv with your package manager. For MacOS, it’s brew install pyenv. Install desired python version: pyenv install \u003cversion\u003e Set global python version pyenv global \u003cversion\u003e Set up your shell environment for Pyenv, for zsh, add this to your .","tags":[],"title":"Manage Python Version With Pyenv","type":"post"},{"authors":null,"categories":[],"content":"As a competitive programmer, I always want to find a solution to avoid copy-and-pasting my algorithm library so I can write more complex code lol.\nInspired by Egor’s rust bundler, I wondered is there something similar for C++? I remembered that I read this long time ago then I spent some time finding that blog but it’s not a bundler and looks quite complicated. In the comment someone mentioned using the cpp command which does the preprocessing work. As you may know, #include is basically copy-and-paste so this actually sounds right, but the problem is that it also copies and pastes the standard library which is over 200k+ lines of code. So I dug a bit further to see if it’s possible to skip system header and found this, but it only works for clang which what I’m using so I didn’t look for a solution for gcc.\nThe command is:\nclang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc main.cpp \u0026gt; bundled.cpp Explanation:\n-E Only run the preprocessor -P Disable linemarker output in -E mode -nostdinc++ Disable standard #include directories for the C++ standard library -nobuiltininc Disable builtin #include directories (may not be needed) As #include of system header isn’t preserved, you can add the system headers using another command and I made a shell function to do that:\nexpand_cpp () { clang++ -I/your/path/to/library/ -E -P -nostdinc++ -nobuiltininc $1 \u0026gt; bundled.cpp gsed -i \u0026#34;1s/^/#include \u0026lt;bits\\/stdc++.h\u0026gt;\\n/\u0026#34; bundled.cpp } ","date":1658497915,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1658497915,"objectID":"2aaf534fcdf3f74676cef5dea201c42e","permalink":"thallium.github.io/tgc54.com/post/bundle-cpp-code/","publishdate":"2022-07-22T09:51:55-04:00","relpermalink":"thallium.github.io/tgc54.com/post/bundle-cpp-code/","section":"post","summary":"As a competitive programmer, I always want to find a solution to avoid copy-and-pasting my algorithm library so I can write more complex code lol.\nInspired by Egor’s rust bundler, I wondered is there something similar for C++?","tags":["Tricks"],"title":"Bundle C++ Code with Clang","type":"post"},{"authors":null,"categories":["Tutorial"],"content":"If you are developing a simple static website like a blog or wiki, you probably don’t really like to play with a hosting service involving a remote repository like GitHub pages. Pushing to the remote repo every time you make changes and waiting for the building process is not that pleasant. With Cloudflare Workers/Pages, you can upload your website directly using Wrangler.\nInstallation Install Wrangler globally:\nnpm install -g wrangler Authentication There are two ways of authentication:\nIf you are using it on your own computer, you can use OAuth in your browser to login by running wrangler login. set CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID environmental variables. API token can be generated here for workers, you can use the “Edit Cloudflare Workers” template. for pages, follow the offical guice here. To find your account ID, log in to the Cloudflare dashboard \u0026gt; select your zone in Account Home \u0026gt; find your account ID in Overview under API on the right-side menu. Cloudflare Workers Cloudflare Worker is flexible and powerful. You can do much more than hosting website. You websites are stored in the KV storage.\nTo deploy your website:\ncopy wrangler.toml to your project directory. change bucket to your website directory, e.g. public folder for a hugo website. optionally, add route = \u0026#34;your-domain.com/*\u0026#34; to set custom domain/route for your website. create src folder and copy index.js in the src folder, run npm i @cloudflare/kv-asset-handler finally, back to the folder where you put wrangler.toml, run wrangler publish to deploy your website. Cloudflare Pages Cloudflare Pages is meant to replace the website hosting functionality of Workers. It supports lots of front-end framework so you can deploy your front-end application very easily. You can still upload locally with wrangler but it doesn’t work that well (it failed to upload my hugo blog).\nThe upload is pretty easy: simple run wrangler pages publish \u0026lt;directory\u0026gt; and follow the instruction.\n","date":1653138941,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1653138941,"objectID":"05d7e1cdaf88add45ffac425242b25cc","permalink":"thallium.github.io/tgc54.com/post/cloudflare-workers-and-pages/","publishdate":"2022-05-21T09:15:41-04:00","relpermalink":"thallium.github.io/tgc54.com/post/cloudflare-workers-and-pages/","section":"post","summary":"Cloudflare is the new contender in the hosting service.","tags":["cloudflare"],"title":"Fast Static Website Deployment with Cloudflare Workers and Pages","type":"post"},{"authors":null,"categories":["Solutions"],"content":"This problem is North American Invitational Programming Contest (NAIPC) 2014 F，link to the problem。\nSolution As n is small, we can consider brute force each shortest path. Then let’s rephrase the problem: we first take the gold from all the village on the path to the castle, then we return it if we go through a village that we steal before when returning to home. Then finding the returning path becomes a shortest path problem: the cost of the vertex $i$ is $a_i$ if we steal it before, is 0 otherwise.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; vector\u0026lt;int\u0026gt; a(n); for (int i = 2; i \u0026lt; n; i++) cin \u0026gt;\u0026gt; a[i]; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; g(n); for (int i = 0; i \u0026lt; m; i++) { int u, v; cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v; u--, v--; g[u].push_back(v); g[v].push_back(u); } queue\u0026lt;int\u0026gt; q; q.push(0); vector\u0026lt;int\u0026gt; dep(n, -1); dep[0] = 0; while (!q.empty()) { auto u = q.front(); q.pop(); for (auto v : g[u]) { if (dep[v] == -1) { dep[v] = dep[u] + 1; q.push(v); } } } int ans = 0; vector\u0026lt;bool\u0026gt; vis(n); auto dijkstra = [\u0026amp;]() { vector\u0026lt;int\u0026gt; dis(n, -1); priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, greater\u0026lt;\u0026gt;\u0026gt; q; dis[0] = 0; q.emplace(0, 0); while (!q.empty()) { auto [d, u] = q.top(); q.pop(); if (d != dis[u]) continue; for (auto v : g[u]) { int nd = d + (vis[v] ? a[v] : 0); if (dis[v] == -1 || nd \u0026lt; dis[v]) { dis[v] = nd; q.emplace(nd, v); } } } int sum = 0; for (int i = 0; i \u0026lt; n; i++) { if (vis[i]) sum += a[i]; } ans = max(ans, sum - dis[1]); }; auto dfs = [\u0026amp;](auto \u0026amp;me, int u) -\u0026gt; void { vis[u] = true; for (auto v : g[u]) { if (v == 1) dijkstra(); else if (dep[v] == dep[u] + 1 \u0026amp;\u0026amp; dep[v] \u0026lt; dep[1]) me(me, v); } vis[u] = false; }; dfs(dfs, 0); cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; return 0; } ","date":1624494507,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1624494507,"objectID":"81c5f85d5da19f1f812f69539e7a3d8a","permalink":"thallium.github.io/tgc54.com/post/kattis-goldbandits/","publishdate":"2021-06-23T20:28:27-04:00","relpermalink":"thallium.github.io/tgc54.com/post/kattis-goldbandits/","section":"post","summary":"","tags":["BFS","Shortest Path","Graph Theory"],"title":"Solution to NAIPC2014 F - Gold Bandits","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Interesting technique.\nSolution We create an auxiliary array $b$ where $b_i$ is the index of the next $k$-th occurrence of $a_i$, or $n+1$ if such occurrence doesn’t exist. For example, the auxiliary array of the example input should be [3, 7, 7, 6, 7, 7].\nConsider query $(l, r)$, for $i\\in [l, r]$, if $b_i\\le r$, this means that there are more than $k$ occurrences of $a_i$ after $i$ so $i$ should not be in the army. Thus the answer to the query is $r-l+1-|\\{b_i|b_i\\le r, i\\in[l, r]\\}|$. Finding the number of elements in a range that are smaller than $x$ is a classic problem that can be solved with persistent segment tree or wavelet tree.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; struct PST { int n, tot=0; vector\u0026lt;int\u0026gt; lc, rc, sum, roots; // left child, right child PST(int n_) : n(n_), lc(n\u0026lt;\u0026lt;5), rc(n\u0026lt;\u0026lt;5), sum(n\u0026lt;\u0026lt;5), roots(1) { build(0, n-1, roots[0]); } void pushup(int rt) { sum[rt] = sum[lc[rt]] + sum[rc[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lc[rt]); build(mid + 1, r, rc[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int old, int\u0026amp; rt) { rt = ++tot; lc[rt] = lc[old]; rc[rt] = rc[old]; if (l == r) { sum[rt] = sum[old] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lc[old], lc[rt]); else update(pos, val, mid + 1, r, rc[old], rc[rt]); pushup(rt); } int update(int pos, int val) { // return the root of the new version int new_root; update(pos, val, 0, n-1, roots.back(), new_root); roots.push_back(new_root); return new_root; } int query(int u, int v, int l, int r, int k) { if (l==r) return sum[v]-sum[u]; int mid=(l+r)/2, x=sum[lc[v]]-sum[lc[u]]; if (mid\u0026lt;k) return x+query(rc[u], rc[v], mid+1, r, k); return query(lc[u], lc[v], l, mid, k); } int query(int u, int v, int k) { return query(u, v, 0, n-1, k); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; constexpr int M=1e5; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(M); vector\u0026lt;int\u0026gt; a(n, n); for (int i=0; i\u0026lt;n; i++) { int x; cin\u0026gt;\u0026gt;x; pos[x].push_back(i); if (pos[x].size()\u0026gt;k) { a[*(pos[x].rbegin()+k)]=i; } } int last=0; vector\u0026lt;int\u0026gt; roots(n+1); roots[0]=1; PST tr(n+1); for (int i=0; i\u0026lt;n; i++) { roots[i+1]=tr.update(a[i], 1); } int q; cin\u0026gt;\u0026gt;q; while (q--) { int x, y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=(x+last)%n, r=(y+last)%n; if (l\u0026gt;r) swap(l, r); last=(r-l+1)-tr.query(roots[l], roots[r+1], r); cout\u0026lt;\u0026lt;last\u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; } return 0; } ","date":1621648547,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621648547,"objectID":"3a9ab9456f9cd71870b71a35fcab982d","permalink":"thallium.github.io/tgc54.com/post/cf813e/","publishdate":"2021-05-21T21:55:47-04:00","relpermalink":"thallium.github.io/tgc54.com/post/cf813e/","section":"post","summary":"Interesting technique.\n","tags":["Data Structure","Persistent Segment Tree"],"title":"Solution for CodeForces 813E - Army Creation","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution 1: Suffix Array For each suffix starting from $i$, the length of the shortest unique substring which is a prefix of that suffix is $\\max(lcp_i, lcp_{i+1})+1$ where $lcp_0$ and $lcp_{n}$ is defined to be $0$. Note that if that length is greater than the length of suffix, it’s an invalid substring\nCode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; vector\u0026lt;int\u0026gt; suffix_array(string s) { s+=\u0026#34;#\u0026#34;; int n = s.size(), N = n + 256; vector\u0026lt;int\u0026gt; sa(n), ra(n); for(int i = 0; i \u0026lt; n; i++) sa[i] = i, ra[i] = s[i]; for(int k = 0; k \u0026lt; n; k ? k *= 2 : k++) { vector\u0026lt;int\u0026gt; nsa(sa), nra(n), cnt(N); for(int i = 0; i \u0026lt; n; i++) nsa[i] = (nsa[i] - k + n) % n; for(int i = 0; i \u0026lt; n; i++) cnt[ra[i]]++; for(int i = 1; i \u0026lt; N; i++) cnt[i] += cnt[i - 1]; for(int i = n - 1; i \u0026gt;= 0; i--) sa[--cnt[ra[nsa[i]]]] = nsa[i]; int r = 0; for(int i = 1; i \u0026lt; n; i++) { if(ra[sa[i]] != ra[sa[i - 1]]) r++; else if(ra[(sa[i] + k) % n] != ra[(sa[i - 1] + k) % n]) r++; nra[sa[i]] = r; } ra = nra; } sa.erase(sa.begin()); return sa; } vector\u0026lt;int\u0026gt; build_lcp(const string\u0026amp; s, const vector\u0026lt;int\u0026gt;\u0026amp; sa) { int n=s.size(); vector\u0026lt;int\u0026gt; pos(n); for (int i = 0; i \u0026lt; n; i++) pos[sa[i]] = i; vector\u0026lt;int\u0026gt; lcp(n); int k = 0; for (int i = 0; i \u0026lt; n; i++) { if (pos[i]==0) continue; if (k) k--; while (s[i+k] == s[sa[pos[i]-1]+k]) k++; lcp[pos[i]] = k; } return lcp; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; auto sa=suffix_array(s); auto lcp=build_lcp(s, sa); lcp.push_back(0); int ans=s.size(); int l=0; for (int i=1; i\u0026lt;(int)s.size(); i++) { int len=max(lcp[i], lcp[i+1])+1; if (len\u0026gt;s.size()-sa[i]) continue; if (len\u0026lt;ans) { ans=len; l=sa[i]; } else if (len==ans) l=min(l, sa[i]); } cout\u0026lt;\u0026lt;s.substr(l, ans); } Solution 2: Binary Search + String Hashing Note that if a substring is unique, then all the other substrings containing that substring is also unique. So we can binary search the length of the substring.\nFor each length, we check if there is a unique substring in all the substrings of that length using hashing. One way of calculating hash value of a substring efficiently is to precalculate hash value of all prefixes (like prefix sum). Note that in the implementation, we let the left position be more significant bit in order to avoid division.\nCode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); constexpr int mod=1e9+7; vector\u0026lt;ll\u0026gt; pow(n+1), ha(n+1); pow[0]=1; for (int i=1; i\u0026lt;=n; i++) { pow[i]=pow[i-1]*233%mod; ha[i]=(ha[i-1]*233+s[i-1])%mod; } auto get_hash=[\u0026amp;](int l, int r) { l++, r++; return (ha[r]-ha[l-1]*pow[r-l+1]%mod+mod)%mod; }; auto check=[\u0026amp;](int len) { unordered_map\u0026lt;int, int\u0026gt; cnt; for (int i=0; i+len-1\u0026lt;n; i++) { cnt[get_hash(i, i+len-1)]++; } for (int i=0; i+len-1\u0026lt;n; i++) { if(cnt[get_hash(i, i+len-1)]==1) return i; } return -1; }; int l=1, r=n; while (l\u0026lt;=r) { int mid = (l+r)/2; if (check(mid)!=-1) { r=mid-1; } else { l=mid+1; } } int ans=check(l); cout\u0026lt;\u0026lt;s.substr(ans, l); } ","date":1621350038,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621350038,"objectID":"ad1ecd57211d38bbfa11b4a9f1868c73","permalink":"thallium.github.io/tgc54.com/post/2020_swerc_k/","publishdate":"2021-05-18T11:00:38-04:00","relpermalink":"thallium.github.io/tgc54.com/post/2020_swerc_k/","section":"post","summary":"","tags":["Suffix Array","Binary Search","Hashing"],"title":"Solution for 2020 ICPC SWERC K - Unique Activities","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Went the wrong direction during the contest. 😞\nSolution Let the number of edges of the polygons be $e1, e2, \\dots, e_n$. It’s easy to find that $e_i$ has to be a multiple of $e_{i-1}$, thus we can rewrite $e$ as $e_1\\cdot 1, e_1\\cdot k_2, \\dots, e_1\\cdot k_n$. Hence if we know the number of edges of the first polygon, all we left if to find the longest sequence $$k_1=1, k_2, k_3, \\dots, k_n$$ such that $k_i$ is a multiple if $k_{i-1}$ and $\\sum_i k_i=K$.\nNote that $k_2, k_3,\\dots, k_n$ are all multiple of $k_2$, so if we divide them by $k_2$ we get a sequence starting with $1$ again! This means we get a smaller subproblem and we can use dynamic programming to solve it: let $dp_i$ be the length of the longest such sequence described above which sums to $i$. Since we can get a longer sequence by multiplying a shorter one by a constant and prepending a $1$, so the transition is: $$dp_{k\\cdot i+1}\\coloneqq \\max(dp_{k\\cdot i+1}, dp_i+1), k=2,3,\\dots$$\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt = 1; cin \u0026gt;\u0026gt; tt; constexpr int N = 1e6; vector\u0026lt;int\u0026gt; dp(N + 1, 1); for (int i = 1; i \u0026lt;= N; i++) { for (int j = 2 * i + 1; j \u0026lt;= N; j += i) { dp[j] = max(dp[j], dp[i] + 1); } } for (int cas = 1; cas \u0026lt;= tt; cas++) { int x; cin \u0026gt;\u0026gt; x; int ans = 1; cout \u0026lt;\u0026lt; \u0026#34;Case #\u0026#34; \u0026lt;\u0026lt; cas \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (int f = 3; f \u0026lt;= x; f++) { if (x % f == 0) ans = max(ans, dp[x / f]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } return 0; } ","date":1621111156,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1621111156,"objectID":"b30eab7750270e7a43def446e7f8d22d","permalink":"thallium.github.io/tgc54.com/post/gcj2021_r2_matrygons/","publishdate":"2021-05-15T16:39:16-04:00","relpermalink":"thallium.github.io/tgc54.com/post/gcj2021_r2_matrygons/","section":"post","summary":"Went the wrong direction during the contest. 😞\n","tags":["DP"],"title":"Solution for Google Code Jam 2021 R2 Matrygons","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Feels pretty standard, but I was too bad at that time. Good problem.\nSolution For brevity, let’s use $0,1,2,3,4$ denote A, E, I, O, U.\nLet $\\textit {EndCost}_{i, j}$ be the cost to put all the bins of type $i$ consecutively to where ends at $j$.\nFor the 5 types of bins, there’s are $5!$ combinations of relative order. Let $\\textit {BestCost}_{i, j}$ be the best cost to put $i$ types of bins such that the last type of bins ends at $j$. Obviously, $\\textit{BestCost}_{1}$ can be one of of $\\textit{EndCost}_i, i=0,\\dots,4$.\nFor $i=2,\\dots, 5$, $\\textit{BestCost}_{i, j}$ can be calculated from $\\textit{BestCost}_{i-1, j}$:\n$$\\textit{BestCost} _{i,jj}=\\min _{j\\le jj-cnt_k}\\textit{BestCost} _{i-1, j}+\\textit{EndCost} _{k, j},~~\\text{for each type } k=0,\\dots,5$$\nTime complexity: $O(5^5\\cdot n^2)$ (correct me if I’m wrong).\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s; cin\u0026gt;\u0026gt;s; int n=(int)s.size(); vector\u0026lt;int\u0026gt; a(n), bins(n); for (auto\u0026amp; i : a) cin\u0026gt;\u0026gt;i; map\u0026lt;char, int\u0026gt; mp{{\u0026#39;A\u0026#39;, 0}, {\u0026#39;E\u0026#39;, 1}, {\u0026#39;I\u0026#39;, 2}, {\u0026#39;O\u0026#39;, 3}, {\u0026#39;U\u0026#39;, 4}}; int cnt[5]{}, totalCost[5]{}; int d; cin\u0026gt;\u0026gt;d; while (d--) { int x; cin\u0026gt;\u0026gt;x; x--; a[x]=0; s[x]=\u0026#39;X\u0026#39;; } for (int i=0; i\u0026lt;n; i++) { auto c=s[i]; if (c!=\u0026#39;X\u0026#39;) { cnt[mp[c]]++; totalCost[mp[c]]+=a[i]; bins[i]=mp[c]; } else bins[i]=-1; } string t; cin\u0026gt;\u0026gt;t; if (t!=\u0026#34;X\u0026#34;) for (auto c : t) cnt[mp[c]]++; constexpr int INF=1e9; vector endCost(5, vector(n, INF)); auto bestCost=endCost; for (int bin=0; bin\u0026lt;5; bin++) { for (int i=0; i\u0026lt;n; i++) { if (i\u0026gt;=cnt[bin]-1) { endCost[bin][i]=totalCost[bin]; for (int j=0; j\u0026lt;cnt[bin]; j++) { if (bins[i-j]==bin) endCost[bin][i]-=a[i-j]; } } } } int ans=1e9; vector\u0026lt;bool\u0026gt; available(5, true); auto solve=[\u0026amp;](auto\u0026amp; solve, int level) -\u0026gt; void{ if (level==0) { for (int o=0; o\u0026lt;5; o++) { available[o]=false; bestCost[0]=endCost[o]; solve(solve, 1); available[o]=true; } } else if (level==5) { ans=min(ans, *min_element(bestCost[4].begin(), bestCost[4].end())); } else { for (int o=0; o\u0026lt;5; o++) { if (available[o]) { available[o]=false; int spaceNeeded=0; for (int o2=0; o2\u0026lt;5; o2++) { if (!available[o2]) spaceNeeded+=cnt[o2]; } for (int i=0; i\u0026lt;n; i++) { bestCost[level][i]=INF; if (i\u0026gt;=spaceNeeded-1) { for (int j=0; j\u0026lt;i-cnt[o]+1; j++) { bestCost[level][i]=min(bestCost[level][i], bestCost[level-1][j]+endCost[o][i]); } } } solve(solve, level+1); available[o]=true; } } } }; solve(solve, 0); cout\u0026lt;\u0026lt;ans; return 0; } ","date":1611446400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1611446400,"objectID":"e516a03be95acc566377e6eca34a71d8","permalink":"thallium.github.io/tgc54.com/post/2019_ecna_k/","publishdate":"2021-01-24T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/2019_ecna_k/","section":"post","summary":"Feels pretty standard, but I was too bad at that time. Good problem.\n","tags":["DP"],"title":"Tutorial for 2019 ICPC East Central North American(ECNA) Regional Contest K - Where Have You Bin","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Easy to think but hard to write.\nSolution Since the radius of a circle is at most 5, we only need to check the status of 10 blocks before it, which could be represented as a binary number. Let $dp_{i, j}$ be the number of ways to draw circles whose right boundary is $i$, with mask of $j$. Here if the k-th bit of the mask is 1, it means that you can put a circle whose left boundary is $i-k$.\nFor a fixed right boundary, there are 5 possible positions for center, so $2^5$ circle combinations. So our strategy is that for each position, we check $2^{10}$ masks and $2^5$ circle combinations, then transition if possible.\nIn order to make coding easier, we could calculate some helper array: le is the mask for the left boundary of the corresponding center mask, all the bits in mhi[i] to the right of the highest bit of le[i] is set to 1 to make positions inside the circle unavailable for the next position.\nCode Credits\n#include \u0026lt;bits/stdc++.h\u0026gt; #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) using namespace std; using ll = long long; using pii = pair\u0026lt;int, int\u0026gt;; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} constexpr int mod=1e9+7; ll dp[1010][1\u0026lt;\u0026lt;10]; int already[1010]; int le[32], mhi[32]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; for (int i=0; i\u0026lt;k; i++) { int c, r; cin\u0026gt;\u0026gt;c\u0026gt;\u0026gt;r; already[c+r]|=(1\u0026lt;\u0026lt;(r-1)); } for (int i=0; i\u0026lt;32; i++) { for (int j=0; j\u0026lt;5; j++) { if (i\u0026gt;\u0026gt;j\u0026amp;1) { le[i]|=(1\u0026lt;\u0026lt;(2*j+1)); mhi[i]=(1\u0026lt;\u0026lt;(2*j+1))-1; } } } dp[0][0]=1; for (int i=0; i\u0026lt;=n; i++) { for (int mask=0; mask\u0026lt;1024; mask++) { if (!dp[i][mask]) continue; for (int k=0; k\u0026lt;32; k++) { if ((already[i]\u0026amp;k) != already[i]) continue; if ((mask \u0026amp; le[k]) != le[k]) continue; int nxt=mask-(mask \u0026amp; mhi[k]); nxt=(2*nxt+1)\u0026amp;1023; (dp[i+1][nxt]+=dp[i][mask])%=mod; } } } ll ans=0; for (int i=0; i\u0026lt;1024; i++) (ans+=dp[n+1][i])%=mod; cout\u0026lt;\u0026lt;ans; return 0; } ","date":1610236800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1610236800,"objectID":"81cf1ab431440474cc6806336034c704","permalink":"thallium.github.io/tgc54.com/post/gym102843j/","publishdate":"2021-01-10T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/gym102843j/","section":"post","summary":"Easy to think but hard to write.\n","tags":["DP"],"title":"Tutorial for 2020 CCPC Changchun Onsite J (GYM102832J) - Abstract Painting","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s consider the case where $\\max(h_{i + 1}, \\ldots, h_{j - 1}) \u0026lt; \\min(h_i, h_j)$. $h_i$ could be lower or higher than $h_j$. There can be multiple $i$ that satisfies the condition and we can observe the leftmost $i$ is the first that $h_i\\ge h_j$, let’s denote this $i_{min}$, other $i$ between $[i_{min},j]$ must satisfy that $h_i$ is the maximum value among $[i,j-1]$. This can be solved using monotonic stack. Assume we store the indices in the stack, when adding a new index $j$, all the indices that will be removed are a valid position to jump to $j$, so we can do dp and update the minimum number of moves. The time complexity is $O(n)$.\nThe second case is similar.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;int\u0026gt; dp(n,n); dp[0]=0; vector\u0026lt;int\u0026gt; h{0},l{0}; for(int i=1;i\u0026lt;n;i++){ dp[i]=min(dp[i],dp[i-1]+1); while(!h.empty()\u0026amp;\u0026amp;a[i]\u0026gt;=a[h.back()]){ int x=a[h.back()]; h.pop_back(); if(a[i]\u0026gt;x\u0026amp;\u0026amp;!h.empty()) dp[i]=min(dp[i],dp[h.back()]+1); } while(!l.empty()\u0026amp;\u0026amp;a[i]\u0026lt;=a[l.back()]){ int x=a[l.back()]; l.pop_back(); if(a[i]\u0026lt;x\u0026amp;\u0026amp;!l.empty()) dp[i]=min(dp[i],dp[l.back()]+1); } h.push_back(i); l.push_back(i); } cout\u0026lt;\u0026lt;dp[n-1]; return 0; } ","date":1599523200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1599523200,"objectID":"f9665c5bb2b9ab3d72814865a3a71848","permalink":"thallium.github.io/tgc54.com/post/cf1407d/","publishdate":"2020-09-08T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1407d/","section":"post","summary":"","tags":["DP","Monotonic Stack"],"title":"Tutorial for CodeForces 1407D","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First, count how many palindromes begin with $s_i$ and let the number be $f_i$.\nThen, find the maximum length $d$ such that $s_{i - k} = t_k$ for each k = 1, 2, …, d and let the length be $g_i$.\nThe answer should be $\\sum_{i=1}^{\\lvert S\\rvert}f_i\\cdot g_i$.\nThe first part can be solved using manacher algorithm, and the second part is equivalent to calculate the longest common prefix (LCP) for every suffix of the reversed string $s$ with $t$, which can be solved using Z algorithm.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() #define sz(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; vector\u0026lt;int\u0026gt; manacher(const string ss){ string s; for(auto ch:ss) s+=\u0026#34;#\u0026#34;,s+=ch; s+=\u0026#34;#\u0026#34;; int n=(int)s.size(); vector\u0026lt;int\u0026gt; d1(n); for (int i = 0, l = 0, r = -1; i \u0026lt; n; i++) { int k = (i \u0026gt; r) ? 1 : min(d1[l + r - i], r - i); while (0 \u0026lt;= i - k \u0026amp;\u0026amp; i + k \u0026lt; n \u0026amp;\u0026amp; s[i - k] == s[i + k]) { k++; } d1[i] = k--; if (i + k \u0026gt; r) { l = i - k; r = i + k; } } return d1; } vector\u0026lt;int\u0026gt; z_function(const string s) { int n = (int)s.size(); vector\u0026lt;int\u0026gt; z(n); for (int i = 1, l = 0, r = 0; i \u0026lt; n; ++i) { if (i \u0026lt;= r) z[i] = min(r - i + 1, z[i - l]); while (i + z[i] \u0026lt; n \u0026amp;\u0026amp; s[z[i]] == s[i + z[i]]) ++z[i]; if (i + z[i] - 1 \u0026gt; r) l = i, r = i + z[i] - 1; } return z; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); string s,t; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t; auto man=manacher(s); vector\u0026lt;int\u0026gt; f(sz(s)); for(int i=1;i\u0026lt;sz(man)-1;i++){ int l=(i-man[i]+1)/2,r=(i-1)/2; f[l]++; if(r\u0026lt;sz(s)-1) f[r+1]--; } partial_sum(all(f),f.begin()); reverse(all(s)); auto g=z_function(t+\u0026#34;#\u0026#34;+s); g.erase(g.begin(),g.begin()+sz(t)+1); reverse(all(g)); g.erase(g.end()-1); g.insert(g.begin(),0); ll ans=0; forn(i,sz(s)) ans+=ll(f[i])*g[i]; cout\u0026lt;\u0026lt;ans; return 0; } ","date":1594252800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1594252800,"objectID":"5c4b9ed7403cda6bc36c9dc6757c7398","permalink":"thallium.github.io/tgc54.com/post/gym101981m/","publishdate":"2020-07-09T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/gym101981m/","section":"post","summary":"","tags":["String","Manacher","Z Algorithm"],"title":"Tutorial 2018-2019 ACM-ICPC, Asia Nanjing Regional Contest M - Mediocre String Problem","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Each element {x,i}in the stack represents a consecutive group of dominos such that if one domino can reach x, all the dominos starting from the i-th position until the next group will fall. So when we move to a new domino, we should firstly pop out all the domino that within the reach of the current domino. Then the top domino would be the closest domino that won’t fall if we pull of the current domino, i.e. the answer for the current domino.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; using pii= pair\u0026lt;int, int\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; x(n),h(n),id(n); iota(all(id),0); forn(i,n){ cin\u0026gt;\u0026gt;x[i]\u0026gt;\u0026gt;h[i]; } sort(all(id),[\u0026amp;](int a,int b){return x[a]\u0026lt;x[b];}); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;pii\u0026gt; stk; stk.push({1e9,n}); for(int i=n-1;i\u0026gt;=0;i--){ int ii=id[i]; while(!stk.empty()\u0026amp;\u0026amp;x[ii]+h[ii]\u0026gt;stk.top().F) stk.pop(); ans[ii]=(stk.empty()?1:stk.top().S-i); stk.push({x[ii],i}); } for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1593907200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1593907200,"objectID":"b47a991a93eebe7514a0f81cfe8c3b6b","permalink":"thallium.github.io/tgc54.com/post/cf56e/","publishdate":"2020-07-05T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf56e/","section":"post","summary":"","tags":["Data Structure","Monotonic Stack"],"title":"Tutorial for Codeforces 56E - Domino Principle","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s find $s_i$: the number of friends who love food $i$. For some food $i$, if $s_i\\leq w_i$, we can see that all the friends who love $i$ will have food to eat no matter what order you call them. So we want to call them as late as possible.\nThe solution is like doing a topological sort or BFS: we start from all the $i$ that $s_i\\leq w_i$. When visiting a new vertex $u$, decrease $s_u$ by one and then if $s_u\\leq w_u$, put $u$ in the queue and put it in the call list. Finally we reverse our call list and that’s the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; a(n),deg(n); for(auto\u0026amp; i:a) cin\u0026gt;\u0026gt;i; vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G(n); forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; x--,y--; deg[x]++,deg[y]++; G[x].pb({y,i}); G[y].pb({x,i}); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; vis(m); queue\u0026lt;int\u0026gt; q; forn(i,n){ if(deg[i]\u0026lt;=a[i]){ q.push(i); } } while(!q.empty()){ int u=q.front(); q.pop(); for(auto [to,i]:G[u]){ if(!vis[i]){ ans.pb(i+1); vis[i]=1; deg[to]--; if(deg[to]\u0026lt;=a[to]) q.push(to); } } } if(sz(ans)!=m) return cout\u0026lt;\u0026lt;\u0026#34;DEAD\u0026#34;,0; reverse(all(ans)); cout\u0026lt;\u0026lt;\u0026#34;ALIVE\\n\u0026#34;; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1592956800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592956800,"objectID":"7c28005f85e98f787102d05237a3b396","permalink":"thallium.github.io/tgc54.com/post/cf1369e/","publishdate":"2020-06-24T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1369e/","section":"post","summary":"","tags":["BFS","Greedy"],"title":"Tutorial for Codeforces 1369E - DeadLee","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution It’s obvious that the images we opened is a sub-segment of all images. We can loop over all the possible left endpoints and use two pointers to find the rightmost endpoint.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,a,b,T; string s; rd( n,a,b,T,s); int ans=0; vector\u0026lt;ll\u0026gt; t(2*n); forn(i,n){ t[i]=t[i+n]=(s[i]==\u0026#39;w\u0026#39;?b+1:1); } for(int i=1;i\u0026lt;2*n;i++) t[i]+=t[i-1]; int r=n; auto f=[\u0026amp;](int l,int r){ ll res=t[r]-t[l-1]; ll di=r-l+min(r-n,n-l); return res+di*a; }; for(int l=1;l\u0026lt;=n;l++){ while(r+1\u0026lt;l+n\u0026amp;\u0026amp;f(l,r+1)\u0026lt;=T) r++; if(f(l,r)\u0026lt;=T) ans=max(ans,r-l+1); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1592784e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592784e3,"objectID":"3aba7fd7567ab1b721a71da866d618ef","permalink":"thallium.github.io/tgc54.com/post/cf650b/","publishdate":"2020-06-22T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf650b/","section":"post","summary":"","tags":["Two Pointers"],"title":"Tutorial for Codeforces 650B/651D Image Preview","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Don’t be intimidated by the official solution.\nSolution First let’s introduce “sorted subsequence”: a sorted subsequence is a subsequence that is a subarray of the sorted array. It’s easy to see that the unmoved elements form a sorted subsequence. So if we find the longest sorted subsequence, the answer is minimized.\nSince we only care about the relative order of numbers, we can compress the number which makes it easier to program. Then for each number we make an array storing all the indices of this number.\nNow let’s iterate over each number. If the smallest index of the current number is greater than the biggest index of the previous number, we can simply add all the index to our subsequence. Otherwise, we need to start a new subsequence. There are two things we should notice:\nPart of the indices of the current number can be added to the old subsequence. E.g. 1,2,1,1,2, the second 2 can be added so we have 1,1,1,2.\nThe new subsequence can also include part of the indices of the previous number. E.g. 1,2,2,1,2 we can add the first 1 to the front so we have 1,2,2,2.\nThere is one special case: the subsequence consists indices of two numbers and indices of both numbers are incomplete. E.g. 2,1,1,2,2,1, it’s easy to see that we need a prefix of the fist number the a suffix of the second number. So we can iterate over each prefix of the first number and find the corresponding suffix of the second number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(),(x).end() #define size(x) int(x.size()) #define pb push_back using namespace std; using ll=long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; for1(T,tt){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n),d(n); forn(i,n){ cin\u0026gt;\u0026gt;a[i]; d[i]=a[i]; } //coord compression sort(all(d)); d.resize(unique(all(d))-d.begin()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(size(d)); forn(i,n){ a[i]=lower_bound(all(d),a[i])-d.begin(); pos[a[i]].push_back(i); } int r=-1,mxlen=0,curlen=0; forn(i,size(d)){ if(pos[i][0]\u0026gt;r){ curlen+=size(pos[i]); }else{ //extend to the right for the old sequence auto j=lower_bound(all(pos[i]),r); mxlen=max(mxlen,curlen+int(pos[i].end()-j)); //extend to the left for the new sequence auto it=lower_bound(all(pos[i-1]),pos[i][0]); curlen=int(it-pos[i-1].begin())+size(pos[i]); } mxlen=max(mxlen,curlen); r=pos[i].back(); } //check the special case: sequence containing only two numbers forn(i,size(d)-1){ forn(j,size(pos[i])){ auto it=lower_bound(all(pos[i+1]),pos[i][j]); mxlen=max(mxlen,j+1+int(pos[i+1].end()-it)); } } cout\u0026lt;\u0026lt;n-mxlen\u0026lt;\u0026lt;endl; } return 0; } ","date":1592438400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592438400,"objectID":"2ac4beec5c23e6378f46ae1c3b0bc574","permalink":"thallium.github.io/tgc54.com/post/cf1367f2/","publishdate":"2020-06-18T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1367f2/","section":"post","summary":"Don’t be intimidated by the official solution.\n","tags":["Greedy","Binary Search"],"title":"Tutorial for Codeforces 1367F2 - Flying Sort (Hard Version)","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution The key observation is that if we fix $l$ then we have $\\max_{i=l}^ra_i-\\min_{i=l}^r b_i\\leq \\max_{i=l}^{r+1}a_i-\\min_{i=l}^{r+1} b_i$. So we can use binary search to find the min and the max value $r$ such that $\\max_{i=l}^r a_i=\\min_{i=l}^r b_i$ and add max-min+1 to the answer. We need a RMQ data structure and sparse table can do this in $O(1)$ per query.\nAlso this can be done using monotone queue but I haven’t figured it out.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; using ll=long long; struct sparse{ int logn; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; f,g; sparse(int n){ logn=__lg(n); f=g=vector(n,vector(logn+1,0)); for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;f[i][0]; for(int i=0;i\u0026lt;n;i++) cin\u0026gt;\u0026gt;g[i][0]; for (int j = 1; j \u0026lt;= logn; j++) for (int i = 0; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt; n; i++){ f[i][j] = max(f[i][j - 1], f[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); g[i][j] = min(g[i][j - 1], g[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } int geta(int x,int y){ int s = __lg(y - x + 1); return max(f[x][s], f[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } int getb(int x,int y){ int s = __lg(y - x + 1); return min(g[x][s], g[y - (1 \u0026lt;\u0026lt; s) + 1][s]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; sparse st(n); ll ans=0; for(int i=0;i\u0026lt;n;i++){ int l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;st.getb(i,mid)) l=mid+1; else r=mid-1; } int left=r; l=i,r=n-1; while(l\u0026lt;=r){ int mid=(l+r)/2; if(st.geta(i,mid)\u0026lt;=st.getb(i,mid)) l=mid+1; else r=mid-1; } ans+=r-left; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1592352e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1592352e3,"objectID":"47429e23e3b5b6361990be440df46bf2","permalink":"thallium.github.io/tgc54.com/post/cf689d/","publishdate":"2020-06-17T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf689d/","section":"post","summary":"","tags":["Binary Search","Data Structure","Sparse Table"],"title":"Tutorial for Codeforces - Friends and Subsequences","type":"post"},{"authors":null,"categories":["Solutions"],"content":"link\nSolution Let’s try to fix the right endpoint first and then find the longest subarray for each right endpoint.\nLet $pos_{x,i}$ be the index of the $i$-th occurrence of number $x$. Assume the current right endpoint is $r\\in[0,n)$, for each $x\\in[1,C]$ The left endpoint can’t fall in the interval $[pos_{x,m-k+1}+1,i]$ where $m$ is the occurrence of $x$ until $r$. This is because if left endpoint in that interval, the occurrence of $x$ would be larger than zero and smaller than $K$, which doesn’t satisfy the constrain. We could add 1 on those intervals and the leftmost endpoint is the smallest index whose value is 0.\nNow let’s consider how the intervals change when the right endpoint moves to $r+1$. It’s easy to see that only the interval for $a_{r+1}$ will change. The interval will change from $[pos_{a_{r+1},m-k}+1,pos_{a_{r+1},m-1}]$ to $[pos_{a_{r+1},m-k+1}+1,pos_{a_{r+1},m}]$. Note that in the implementation we don’t have to change the overlapped interval.\nIn conclusion, we need a data structure that supports range modification and global minimum value query, a.k.a. segment tree.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define size(x) int(x.size()) #define pb push_back using namespace std; struct SegTree{ int n; vector\u0026lt;int\u0026gt; t,lazy,pos; SegTree(int n_):n(n_),t(4*n),lazy(4*n),pos(4*n){ build(1,0,n-1); } void pushup(int node){ t[node]=min(t[node\u0026lt;\u0026lt;1],t[node\u0026lt;\u0026lt;1|1]); pos[node]=(t[node]==t[node\u0026lt;\u0026lt;1]?pos[node\u0026lt;\u0026lt;1]:pos[node\u0026lt;\u0026lt;1|1]); } void build(int node,int l,int r){ if(l==r){ pos[node]=l; return; } int mid=(l+r)\u0026gt;\u0026gt;1; build(node\u0026lt;\u0026lt;1,l,mid); build(node\u0026lt;\u0026lt;1|1,mid+1,r); pushup(node); } void addtag(int p,int x){ t[p]+=x; lazy[p]+=x; } void spread(int p){ if(lazy[p]){ addtag(p\u0026lt;\u0026lt;1,lazy[p]); addtag(p\u0026lt;\u0026lt;1|1,lazy[p]); lazy[p]=0; } } void update(int node,int ql,int qr,int l,int r,int x){ if(ql\u0026lt;=l\u0026amp;\u0026amp;qr\u0026gt;=r){ addtag(node,x); return; } spread(node); int mid=(l+r)\u0026gt;\u0026gt;1; if(ql\u0026lt;=mid) update(node\u0026lt;\u0026lt;1,ql,qr,l,mid,x); if(qr\u0026gt;mid) update(node\u0026lt;\u0026lt;1|1,ql,qr,mid+1,r,x); pushup(node); } int query(int i){ return t[1]==0?i-pos[1]+1:0; } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,c,k; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;c\u0026gt;\u0026gt;k){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pos(c+1,{-1}); vector\u0026lt;int\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; SegTree st(n); int ans=0; forn(i,n){ auto\u0026amp; v=pos[a[i]]; v.pb(i); int sz=size(v)-1; if(sz\u0026lt;k) st.update(1,v[sz-1]+1,i,0,n-1,1); else{ st.update(1,v[sz-k]+1,v[sz-k+1],0,n-1,-1); st.update(1,v[sz-1]+1,i,0,n-1,1); } ans=max(ans,st.query(i)); } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":1591660800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591660800,"objectID":"2867bc62bf649e4b6a55d9fc98409e55","permalink":"thallium.github.io/tgc54.com/post/hdu6602/","publishdate":"2020-06-09T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/hdu6602/","section":"post","summary":"","tags":["Data Structure","Segment Tree"],"title":"Solution for HDU6602 - Longest Subarray","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First, let’s define the function $f_k(i)=a_i+a_{i+1}+\\dots +a_{i+k-1}$, i.e. the sum of $k$ consecutive months starting at $i$.\nNow, let’s prove that if $k$ is one answer and $k\\leq \\dfrac n 2$, then $2\\cdot k$ is also an answer: $f_{2k}(i)=f_k(i)+f_k(i+k)\u0026gt;0$. Thus we can always find an answer greater than $\\dfrac n 2$.\nThen, consider the case where $x\\ge 0$. If $k$ is an answer, since $f_{k+1}(i)=f_k(i)+a_{i+1}=f_k(i)+x\u0026gt;0$, $k+1$ is also an answer. Thus it’s sufficient to check if $k=n$ is the answer.\nLastly, when $x\u0026lt;0$, we need the help of the prefix sum. Define $pre_i=a_0+a_1+\\dots+a_{i-1},i\u0026gt;0$ and $pre_0=0$. We want to find a $k$ such that for each $0\\leq i\\leq n-k$, we have:\n$$\\begin{aligned}pre_{i+k}-pre_i\u0026amp;\u0026gt;0 \\\\ pre_{i}\u0026amp;\u0026lt; pre_{i+k}\\end{aligned}$$\nSince $k\u0026gt;\\dfrac n 2$, the numbers after the window must be $x$, so the formula can be rewrite as:\n$$\\begin{align*}pre _i\u0026amp; \u0026lt; pre _n-x\\cdot(n-k-i) \\\\ pre_i+x\\cdot(n-i)\u0026amp;\u0026lt; pre _n+x\\cdot k\\end{align*}$$\nFor each $i$, the corresponding $k$ is $n-i$, this means if the max value of the LHS is smaller than $pre_n+x\\cdot (n-i)$, then $k=n-i$ is a answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define all(x) (x).begin(), (x).end() using namespace std; using ll = long long; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; vector\u0026lt;ll\u0026gt; a(n); forn(i, (n + 1) / 2) { cin \u0026gt;\u0026gt; a[i]; } int x; cin \u0026gt;\u0026gt; x; for (int i = (n + 1) / 2; i \u0026lt; n; i++) a[i] = x; vector\u0026lt;ll\u0026gt; ps(n + 1); partial_sum(all(a), ps.begin() + 1); if (ps.back() \u0026gt; 0) return cout \u0026lt;\u0026lt; n, 0; if (x \u0026gt;= 0) return cout \u0026lt;\u0026lt; -1, 0; ll N2 = n / 2, N1 = n - N2, sum = ps.back(); ll mx = -1e18; for (int i = 0; i \u0026lt;= N1; i++) { mx = max(mx, ps[i] + x * ll(n - i)); if (mx \u0026lt; sum + x * ll(n - i)) { cout \u0026lt;\u0026lt; n - i; return 0; } } cout \u0026lt;\u0026lt; -1; return 0; } ","date":1590451200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590451200,"objectID":"91cc7b91e3337754cf2aa8fb8d819b77","permalink":"thallium.github.io/tgc54.com/post/cf1358e/","publishdate":"2020-05-26T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1358e/","section":"post","summary":"","tags":null,"title":"Tutorial for Codeforces 1358E - Are You Fired?","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Consider the contribution to the answer of the each occurrence of each substring. Suppose this substring has appeared $c$ times. For a new occurrence of this substring, the answer would change from $c^2$ to $(c+1)^2$, that is to say, each new occurrence contributes $(c+1)^2-c^2=2\\cdot c+1$ to the answer. Since there are $\\dfrac {n\\cdot (n+1)} 2$ substrings, the answer is at least $\\dfrac {n\\cdot (n+1)} 2$ , now what we left is to focusing on finding the occurrence of the substrings. You will see why it’s more handy to do this.\nLet’s build the suffix array and the LCP array first. You will notice that the occurrence of some substring is a subsegment in the suffix array. so is it in the LCP array and the min value of the subsegment in the LCP array is the length of that substring. We can process each of the LCP value in the descending order. This is because each LCP value $lcp_i$ can represent $lcp_i$ substrings, so if we process them in the descending order, we can assure that all the substrings have appeared before.\n","date":1590451200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590451200,"objectID":"c1c172a3419190f7fa08fe11c2b1ec1c","permalink":"thallium.github.io/tgc54.com/post/cf802i/","publishdate":"2020-05-26T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf802i/","section":"post","summary":"","tags":["Suffix Array"],"title":"Tutorial for Codeforces 801I - Fake News (hard)","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Iterate over each frequency. Suppose now we are on frequency $i$. Put all stations with frequency $i$ in the $left$ vector and all radio stations with frequency $[i-k,i+k]$ into the $right$ vector.\nNow we want to calculate the number of pairs such that the left radio station is from the $left$ vector and the right station is from $right$ vector.\nSort the $left$ vector by position and sort the $right$ vector by the left bound of the stations’ range. Iterator the stations in the $left$ vector and put all the stations in the $right$ vector which can reach the current station in the axis(actually we need to put them in some data structure). Now we need to know how many stations in the axis can be reached by the current station. This can be done with some range-sum-query data structure(like fenwick tree): we add one on the position for each new station and use range query to find the stations we want. However, since the positions are up to $10^9$ we also need to compress the coordinate, which is really annoying, so a simpler way to do this is to use a balanced BST in pb_ds library to find the order directly.\nThe lesson learnt is that when we want to find the order, especially with coordinate compression, consider pb_ds.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; #include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt; using namespace __gnu_pbds; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} using ordered_set = tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt;; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;pii\u0026gt; fre[10005]; forn(i,n){ int x,r,f; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;r\u0026gt;\u0026gt;f; fre[f].pb({x,r}); } ll ans=0; auto solve=[\u0026amp;](vector\u0026lt;pii\u0026gt;\u0026amp; left,vector\u0026lt;pii\u0026gt;\u0026amp; right){ sort(all(left)); sort(all(right),[](pii a,pii b){return a.F-a.S\u0026lt;b.F-b.S;}); ll res=0; int i=0; ordered_set tree; for(auto it:left){ while(i\u0026lt;right.size()\u0026amp;\u0026amp;right[i].F-right[i].S\u0026lt;=it.F){ tree.insert(right[i].F); i++; } res+=tree.order_of_key(it.F+it.S+1)-tree.order_of_key(it.F+1); } return res; }; for(int i=1;i\u0026lt;=1e4;i++){ if(fre[i].empty()) continue; vector\u0026lt;pii\u0026gt; left(all(fre[i])),right; for(int j=max(1,i-k);j\u0026lt;=i+k\u0026amp;\u0026amp;j\u0026lt;=10000;j++){ right.insert(right.end(),all(fre[j])); } ans+=solve(left,right); } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1589932800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589932800,"objectID":"62e6df94c6591c5890e08a6dc67ffafb","permalink":"thallium.github.io/tgc54.com/post/cf762e/","publishdate":"2020-05-20T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf762e/","section":"post","summary":"","tags":["Data Structure"],"title":"Tutorial for Codeforces 762E - Radio stations","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution The problem would be a standard dp problem if we can’t go to the left. So we need to handle that extra case. However, we can observe that we don’t need to go more than one cell to the left. Here is a quick proof:\nSo we only need to consider two more transition. Here is all the transition:\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} void inline cmax(ll\u0026amp; a,ll b){ if(b\u0026gt;a) a=b; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;vector\u0026lt;ll\u0026gt;\u0026gt; a(n+2,vector\u0026lt;ll\u0026gt;(3)),dp(n+2,vector\u0026lt;ll\u0026gt;(3,-1e18)); forn(j,3) for1(i,n) cin\u0026gt;\u0026gt;a[i][j]; dp[0][0]=0; for(int i=1;i\u0026lt;=n;i++){ cmax(dp[i][0],max({dp[i-1][0],dp[i-1][1]+a[i][1],dp[i-1][2]+a[i][1]+a[i][2]})+a[i][0]); cmax(dp[i][1],max({dp[i-1][0]+a[i][0],dp[i-1][1],dp[i-1][2]+a[i][2]})+a[i][1]); cmax(dp[i][2],max({dp[i-1][0]+a[i][0]+a[i][1],dp[i-1][1]+a[i][1],dp[i-1][2]})+a[i][2]); cmax(dp[i+1][0],dp[i-1][2]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); cmax(dp[i+1][2],dp[i-1][0]+a[i][0]+a[i][1]+a[i][2]+a[i+1][0]+a[i+1][1]+a[i+1][2]); } cout\u0026lt;\u0026lt;dp[n][2]; return 0; } ","date":1589846400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589846400,"objectID":"333b83d0d98b46960bf52717b4382ca9","permalink":"thallium.github.io/tgc54.com/post/cf762d/","publishdate":"2020-05-19T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf762d/","section":"post","summary":"","tags":["DP"],"title":"Tutorial for Codeforces 762D - Maximum Path","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s minimize the answer. The key observation is that at most one pair passes through the edge $(a,b)$. This is because if two or more pair pass that edge, we can pair two vertices in the same side of that edge and get a better answer.\nFurthermore, the number of pairs that pass through $(a,b)$ is $c_a\\bmod 2$, where $c_a$ the size of the component on a’s side.\nFor the maximized answer, the strategy is similar. The observation is that nodes of one component are paired with node of the other component. We can do the reversed thing in the minimized answer to prove this. Thus, each edge is counted $\\min(c_a,c_b)$ times.\nBoth the maximized answer and the minimized answer can be calculated at the same time in one DFS.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt; G; ll mx,mn; int n; int dfs(int u,int fa){ int sz=1; for(auto [to,w]:G[u]){ if(to==fa) continue; int csz=dfs(to,u); mx+=(ll)w*min(csz,2*n-csz); mn+=ll(w)*(csz%2); sz+=csz; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ cin\u0026gt;\u0026gt;n; G=vector\u0026lt;vector\u0026lt;pii\u0026gt;\u0026gt;(2*n+1); mx=mn=0; forn(i,2*n-1){ int x,y,z; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y\u0026gt;\u0026gt;z; G[x].pb({y,z}); G[y].pb({x,z}); } dfs(1,0); cout\u0026lt;\u0026lt;mn\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;mx\u0026lt;\u0026lt;endl; } return 0; } ","date":158976e4,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":158976e4,"objectID":"8fe3353cbedd6497e150dd52659b1530","permalink":"thallium.github.io/tgc54.com/post/cf1280c/","publishdate":"2020-05-18T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1280c/","section":"post","summary":"","tags":["DFS"],"title":"Tutorial for Codeforces 1280C/1281E Jeremy Bearimy","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Firstly, let’s ignore the third condition for now. Consider the tree is rooted at node 1. Let $dp_i$ be the number of valid sets contain node $i$ and other nodes in the subtree of $i$. This can be easily calculated using a dfs: $dp_i=\\prod_{j\\in child(i)}(dp_j+1)$\nNow consider the third condition. We can set each node to be the smallest value in the valid set respectively. After setting the smallest value, start dfs from node $i$ and only visit nodes $j$ such that $a_i\\leq a_j \\leq a_i+d$. In this case, the third condition is satisfied so we can calculate the answer using the formula above. Also be careful with the duplicate counting, i.e. if $a_j=a_i$, only visit node $j$ such that $j\u0026gt;i$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; int d,n; const int mod=1e9+7; int dfs(int u,int root,int fa){ int sz=1; for(auto to:G[u]){ if(to==fa) continue; if(a[to]\u0026lt;a[root]||a[to]\u0026gt;a[root]+d) continue; if(a[to]==a[root]\u0026amp;\u0026amp;to\u0026lt;root) continue; sz=ll(sz)*(dfs(to,root,u)+1)%mod; } return sz; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin\u0026gt;\u0026gt;d\u0026gt;\u0026gt;n; G.resize(n+1); a.resize(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } int ans=0; for1(i,n){ ans=(ans+dfs(i,i,0))%mod; } cout\u0026lt;\u0026lt;ans; return 0; } ","date":1589500800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589500800,"objectID":"555d30d0da0f99a85f525e4079926910","permalink":"thallium.github.io/tgc54.com/post/cf486d/","publishdate":"2020-05-15T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf486d/","section":"post","summary":"","tags":["DFS","DP"],"title":"Tutorial for Cdoeforces 486D - Valid Sets","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution The problem can be described as checking if there exists a pair of conferences that overlap in one dimension but not in the other dimension. In order to get all the segments that overlap with each other, we should know for all time points, which segments cover it. Specifically, we need some arrays $open_i$ and $close_i$ which store the segments that start at $i$ and close at $i$. So how can we know if there’s a pair of segments that doesn’t overlap on another dimension? We can maintain two multisets, one is the starting points of the current segments, the other is the end points. If the rightmost starting is bigger than the leftmost end point, this means that there exists a pair of segments that doesn’t overlap.\nNote that we need to compress the time points and check both dimension.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); typedef vector\u0026lt;int\u0026gt; vi; bool check(vi\u0026amp; sa,vi\u0026amp; ea,vi\u0026amp; sb,vi\u0026amp; eb,int m){ vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; l(m),r(m); int n=sa.size(); forn(i,n){ l[sa[i]].pb(i); r[ea[i]].pb(i); } multiset\u0026lt;int,greater\u0026lt;int\u0026gt;\u0026gt; lmax; multiset\u0026lt;int\u0026gt; rmin; forn(i,m){ for(auto id:l[i]) lmax.insert(sb[id]),rmin.insert(eb[id]); if(!empty(lmax)\u0026amp;\u0026amp; *lmax.begin()\u0026gt; *rmin.begin()) return 0; for(auto id:r[i]){ lmax.erase(lmax.find(sb[id])); rmin.erase(rmin.find(eb[id])); } } return 1; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; sa(n),sb(n),ea(n),eb(n); forn(i,n) rd(sa[i],ea[i],sb[i],eb[i]); vector\u0026lt;int\u0026gt; time;time.reserve(4*n); for(auto it:sa) time.pb(it); for(auto it:ea) time.pb(it); for(auto it:sb) time.pb(it); for(auto it:eb) time.pb(it); sort(all(time)); time.resize(unique(all(time))-time.begin()); forn(i,n){ sa[i]=lower_bound(all(time),sa[i])-time.begin(); ea[i]=lower_bound(all(time),ea[i])-time.begin(); sb[i]=lower_bound(all(time),sb[i])-time.begin(); eb[i]=lower_bound(all(time),eb[i])-time.begin(); } if(check(sa,ea,sb,eb,time.size())\u0026amp;\u0026amp; check(sb,eb,sa,ea,time.size())) cout\u0026lt;\u0026lt;\u0026#34;YES\u0026#34;; else cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; return 0; } ","date":1589414400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589414400,"objectID":"519c9a81544aaddedb1cccaf7b3c8135","permalink":"thallium.github.io/tgc54.com/post/cf1284d/","publishdate":"2020-05-14T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1284d/","section":"post","summary":"","tags":["Data Structure"],"title":"Tutorial for Codeforces 1284D - New Year and Conference","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Let’s call a cell bad if no adjacent cell has the same color, otherwise that cell is good.\nIf a good cell and a bad cell are adjacent, according to the definition, the good cell will change color in the next iteration while the bad cell not. As the result, the bad cell will turn into a good cell. Therefore, a bad cell won’t change if all the cells are bad cells, otherwise it will become good when the nearest good cell reaches it. The left thing is to find the nearest good cell for all cells. This can be done using multi-source bfs.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... T\u0026gt; void rd(T\u0026amp;... args) {((cin\u0026gt;\u0026gt;args), ...);} template\u0026lt;typename... T\u0026gt; void wr(T... args) {((cout\u0026lt;\u0026lt;args\u0026lt;\u0026lt;\u0026#34; \u0026#34;), ...);cout\u0026lt;\u0026lt;endl;} const vector\u0026lt;pii\u0026gt; dir{{1,0,},{-1,0},{0,1},{0,-1}}; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,t; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;t; vector\u0026lt;string\u0026gt; G(n); for(auto\u0026amp; it:G) cin\u0026gt;\u0026gt;it; queue\u0026lt;pii\u0026gt; q; auto cango=[\u0026amp;](int x,int y){ return x\u0026gt;=0\u0026amp;\u0026amp;x\u0026lt;n\u0026amp;\u0026amp;y\u0026gt;=0\u0026amp;\u0026amp;y\u0026lt;m; }; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dis(n,vector\u0026lt;int\u0026gt;(m,-1)); forn(i,n){ forn(j,m){ bool ok=0; for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;G[x][y]==G[i][j]) ok=1; } if(ok){ dis[i][j]=0; q.emplace(i,j); } } } while(!q.empty()){ auto [i,j]=q.front(); q.pop(); for(auto [dx,dy]:dir){ int x=i+dx,y=j+dy; if(cango(x,y)\u0026amp;\u0026amp;dis[x][y]==-1){ dis[x][y]=dis[i][j]+1; q.emplace(x,y); } } } while(t--){ int i,j; ll p; cin\u0026gt;\u0026gt;i\u0026gt;\u0026gt;j\u0026gt;\u0026gt;p; i--,j--; if(dis[i][j]==-1) cout\u0026lt;\u0026lt;G[i][j]\u0026lt;\u0026lt;endl; else if(dis[i][j]\u0026gt;=p) cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;))\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;((G[i][j]-\u0026#39;0\u0026#39;)^((p-dis[i][j])\u0026amp;1))\u0026lt;\u0026lt;endl; } return 0; } ","date":1589241600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1589241600,"objectID":"7d3df42e3e86a34c870a35a5f234e1b0","permalink":"thallium.github.io/tgc54.com/post/cf1349c/","publishdate":"2020-05-12T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1349c/","section":"post","summary":"","tags":["BFS"],"title":"Solution for Codeforces 1349C/1350E - Orac and Game of Life","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Tutorial A faster way to simulate the process is that instead of moving the hole array, we can add some extra space in front of the array and simply move the element to the extra space. For example, in the sample input:\n5 4 3 5 1 4 The process would look like\n_ _ _ _ 1 2 3 4 5 _ _ _ 3 1 2 _ 4 5 _ _ 5 3 1 2 _ 4 _ _ 1 5 3 _ 2 _ 4 _ 4 1 5 3 _ 2 _ _ _ We can use a fenwick tree to simulate the process: mark a position with 1 if it’s occupied by some number and the prefix sum is how many elements is in front of it (i.e. the real position in the simulator). In the end, don’t forget to update the position of all the elements in case some are not moved.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() #define pb push_back using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void wr(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} struct fenwick{ int n; vector\u0026lt;ll\u0026gt; t; fenwick(int n_):n(n_),t(n+1){} void add(int i,int x){ for(i++;i\u0026lt;=n;i+=i\u0026amp;-i){ t[i]+=x; } } int query(int i){ ll res=0; for(i++;i\u0026gt;0;i-=i\u0026amp;-i) res+=t[i]; return res; } int query(int l,int r){ return query(r)-query(l-1); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; vector\u0026lt;int\u0026gt; l(n),r(n); iota(all(l),0); r=l; vector\u0026lt;int\u0026gt; pos(n); forn(i,n) pos[i]=i+m; fenwick tree(n+m+1); forn(i,n) tree.add(i+m,1); forn(i,m){ int x; cin\u0026gt;\u0026gt;x; x--; l[x]=0; r[x]=max(r[x],tree.query(pos[x]-1)); tree.add(pos[x],-1); pos[x]=m-i-1; tree.add(pos[x],1); } forn(i,n) r[i]=max(r[i],tree.query(pos[i]-1)); forn(i,n) wr(l[i]+1,r[i]+1); return 0; } ","date":1588982400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588982400,"objectID":"1f069561bc0aa9c5dbee54c82961b9fc","permalink":"thallium.github.io/tgc54.com/post/cf1288e/","publishdate":"2020-05-09T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1288e/","section":"post","summary":"","tags":["Data Structure","Fenwick Tree"],"title":"Tutorial for Codeforces 1288E - Messenger Simulator","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First, if $c_i$ is greater than the size of the subtree of node $i$, there’s no answer.\nFor each node we build an array containing all the nodes from the its subtree bottom-up, and these nodes are in ascending order of value written on them (i.e. $a_i$) even though we don’t know the exact value for now. We only care about their relative relationship. The next question is how to combine all the arrays of the children. The answer is quite simple: we can simply glue then together since each subtree is independent. The last step is to put the node in the array. Since we already know $c_i$, so $i$ should be put in the $c_i$-th position of the array.\nNow we have that array containing all the nodes. Let’s call it $order$. We can assign $1,2,3,\\dots$ to $order_1,order_2,order_3,\\dots$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; G; vector\u0026lt;int\u0026gt; c; vector\u0026lt;int\u0026gt; dfs(int u){ vector\u0026lt;int\u0026gt; order; for(auto it:G[u]){ auto child_order=dfs(it); order.insert(order.end(),all(child_order)); } if(size(order)\u0026lt;c[u]){ cout\u0026lt;\u0026lt;\u0026#34;NO\u0026#34;; exit(0); } order.insert(order.begin()+c[u],u); return order; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; G.resize(n+1); c.resize(n+1); int R; for1(i,n){ int pa; cin\u0026gt;\u0026gt;pa\u0026gt;\u0026gt;c[i]; if(pa==0) R=i; G[pa].push_back(i); } auto order=dfs(R); vector\u0026lt;int\u0026gt; ans(n+1); forn(i,n) ans[order[i]]=i+1; cout\u0026lt;\u0026lt;\u0026#34;YES\\n\u0026#34;; for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1588809600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588809600,"objectID":"bd6c3976362e36c89bb2817f0fa40caa","permalink":"thallium.github.io/tgc54.com/post/cf1286b/","publishdate":"2020-05-07T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1286b/","section":"post","summary":"","tags":["DFS"],"title":"Tutorial for Codeforces 1286B/1287D - Numbers on Tree","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First, let’s force Vasya to change tire on everyday with negative temperature (even on consecutive days) so she will change tire for $2\\cdot cnt$ time where $cnt$ is the number of days with negative temperature. If $cnt\u0026gt;k$ obviously the answer is -1, otherwise the winter tire can still last for some extra days. Now let’s see if we can use the winter tire on days with non-negative temperature. We can sort all the length of the consecutive days with non-negative temperature, so we can greedily use winter tires on those segments. For each segment we use, we save tire change twice. Finally let’s see if we can use the winter tire until the last day after the last negative-temperature day.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Ar\u0026gt; void wr(Ar... ar) {((cout\u0026lt;\u0026lt;ar\u0026lt;\u0026lt;\u0026#34; \u0026#34;),...);cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; a(n),neg; forn(i,n){ cin\u0026gt;\u0026gt;a[i]; if(a[i]\u0026lt;0) neg.push_back(i); } if(neg.empty()) return cout\u0026lt;\u0026lt;0,0; if(neg.size()\u0026gt;k) return cout\u0026lt;\u0026lt;-1,0; vector\u0026lt;int\u0026gt; xs; for(int i=1;i\u0026lt;(int)size(neg);i++) xs.push_back(neg[i]-neg[i-1]-1); sort(all(xs)); int ans=int(size(neg))*2; k-=size(neg); for(auto i:xs){ if(k\u0026gt;=i){ k-=i; ans-=2; }else break; } if(n-neg.back()-1\u0026lt;=k) ans--; cout\u0026lt;\u0026lt;ans; return 0; } ","date":1588636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588636800,"objectID":"7ecd4fc91a7e3a9d28e740145fffa096","permalink":"thallium.github.io/tgc54.com/post/cf747d/","publishdate":"2020-05-05T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf747d/","section":"post","summary":"","tags":["Greedy"],"title":"Tutorial for Codeforces 747D - Winter Is Coming","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Very interesting problem.\nSolution The problem is not hard if you know to find the LIS in $O(n\\log n)$ time. Combining LIS and tree problem is quite interesting.\nThe key part of this problem is how to backtrack. I used vector so the backtrack part is a little bit more cumbersome than regular array’s since you have to record whether you add a new element or replace a element. My approach is that if we add a new element, set flag to -1 otherwise set flag to the old number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::steady_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void rd(Args\u0026amp;... args) {((cin \u0026gt;\u0026gt; args), ...);} template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} vector\u0026lt;int\u0026gt; a,ans; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void dfs(int u,int fa,vector\u0026lt;int\u0026gt;\u0026amp; lis){ int flag; int pos=lower_bound(all(lis),a[u])-lis.begin(); if(pos==lis.size()) lis.push_back(a[u]),flag=-1; else flag=lis[pos],lis[pos]=a[u]; ans[u]=lis.size(); for(auto it:G[u]){ if(it==fa) continue; dfs(it,u,lis); } if(flag==-1) lis.pop_back(); else lis[pos]=flag; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a=ans=vector\u0026lt;int\u0026gt;(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].push_back(y); G[y].push_back(x); } vector\u0026lt;int\u0026gt; v{}; dfs(1,-1,v); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;endl; return 0; } ","date":1588377600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1588377600,"objectID":"2e08bc1cfc3133369e06afeb5df416b4","permalink":"thallium.github.io/tgc54.com/post/abc165f/","publishdate":"2020-05-02T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/abc165f/","section":"post","summary":"Very interesting problem.\n","tags":["DFS","DP"],"title":"Solution for AtCoder beginner contest 165F - LIS on Tree","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution Using persistent segment tree, we can know the occurrence of all the number in the given interval. We could easily come up with a naive binary search solution which looks like this:\nint l=0,r=INF; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; if(occurrence_of_numbers_bigger_than(mid)\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; Time complexity is $O(q\\cdot \\log n\\cdot \\log n)$, which suffices but we can still optimize it.\nIn fact, the binary search part could be done during the query on the segment tree. First let’s make some notation: let $[x,y]$ be the interval of the query, $[l,r]$ be the current interval on the segment tree, $s$ be the number of occurrence of numbers ranged in$(r,y]$. The sudo code of the query function would look like this:\nint query(int l,int r,int s){ int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=occurrence_of_number_from_mid_to_r(); if(cnt+s\u0026gt;=mid+1) return query(mid+1,r,s);//the (mid,y] has more numbers than we need, so the answer must be in the right part return query(l,mid,s+cnt);//the numbers in the right part is not enough, so the answer is in the left part. } Now the time complexity is $O(n\\log n)$. Please refer to the code in the end for the better understanding of the implementation.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int pos, int l, int r, int lrt, int rrt) { if (l == r) return sum[rrt] - sum[lrt]; int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) return sum[rson[rrt]] - sum[rson[lrt]] + query(pos, l, mid, lson[lrt], lson[rrt]); return query(pos, mid + 1, r, rson[lrt], rson[rrt]); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int l=0,r=1e5; while(l\u0026lt;=r){ int mid=(l+r)\u0026gt;\u0026gt;1; int ans=tree.query(mid,1,n,tree.root[x-1],tree.root[y]); if(ans\u0026gt;=mid) l=mid+1; else r=mid-1; } cout\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } } return 0; } #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(), (x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); struct PerSegTree { vector\u0026lt;int\u0026gt; lson, rson, sum, root; int tot; PerSegTree(int n) { lson = rson = sum = vector\u0026lt;int\u0026gt;(n \u0026lt;\u0026lt; 5); root = vector\u0026lt;int\u0026gt;(n + 1); tot = 0; } void pushup(int rt) { sum[rt] = sum[lson[rt]] + sum[rson[rt]]; } void build(int l, int r, int\u0026amp; rt) { rt = ++tot; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, lson[rt]); build(mid + 1, r, rson[rt]); pushup(rt); } void update(int pos, int val, int l, int r, int ord, int\u0026amp; rt) { rt = ++tot; lson[rt] = lson[ord]; rson[rt] = rson[ord]; if (l == r) { sum[rt] = sum[ord] + val; return; } int mid = (l + r) \u0026gt;\u0026gt; 1; if (pos \u0026lt;= mid) update(pos, val, l, mid, lson[ord], lson[rt]); else update(pos, val, mid + 1, r, rson[ord], rson[rt]); pushup(rt); } int query(int l, int r, int old_rt, int rt,int s) { if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; int cnt=sum[rson[rt]]-sum[rson[old_rt]]; if(mid\u0026lt;cnt+s) return query(mid+1,r,rson[old_rt],rson[rt],s); return query(l,mid,lson[old_rt],lson[rt],s+cnt); } }; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; while(cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q){ PerSegTree tree(n); tree.build(1,n,tree.root[0]); for1(i,n){ int x; cin\u0026gt;\u0026gt;x; tree.update(x,1,1,n,tree.root[i-1],tree.root[i]); } while(q--){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; cout\u0026lt;\u0026lt;tree.query(1,n,tree.root[x-1],tree.root[y],0)\u0026lt;\u0026lt;endl; } } return 0; } ","date":1587168e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1587168e3,"objectID":"1a8d66665f51a37125f3e18ebd58c870","permalink":"thallium.github.io/tgc54.com/post/hdu6278/","publishdate":"2020-04-18T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/hdu6278/","section":"post","summary":"","tags":["Data Structure","Segment Tree","Persistent Segment Tree","Binary Search"],"title":"Editorial for HDU6278 - Just h-index","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s factor $D$, so $D=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. According to the definition, to factors are connected iff they differ by only one prime factor. And the weight of the edge is $d(x)-d(y)$ where $d(i)$ is the number of factors of $i$. So the length of a path where $v_1\u0026lt;v_2\u0026lt;\\dots\u0026lt;v_k$ is $d(v_k)-d(v_i)$\nThere are only two types of paths between $x$ and $y$, one is $x \\rightarrow\\gcd(x,y)\\rightarrow y$ and the other is $x \\rightarrow \\operatorname{lcm}(x,y) \\rightarrow y$. The length of the path of the first type is\n$$d(x)-d(\\gcd(x,y))+d(y)+d(\\gcd(x,y))=d(x)+d(y)-2\\cdot d(\\gcd(x,y))$$\nThe length of the second type is\n$$d(\\operatorname{lcm}(x,y))-d(x)+d(\\operatorname{lcm}(x,y))-d(y)=2\\cdot d(\\operatorname{lcm}(x,y))-d(x)-d(y)$$\nIntuition tells us first type is always the shortest path.\nAll we need now is to calculate the number of shortest paths. Let $\\frac x {\\gcd(x,y)}=p_1^{e_1}p_2^{e_2}\\dots p_k^{e_k}$. The number of shortest path between $x$ and $\\gcd(x,y)$ is\n$$\\dfrac {(e_1+e_2+\\dots e_k)!}{e_1!\\cdot e_2!\\cdot\\ldots\\cdot e_k!}$$\nSimilarly we can calculate the number of paths between $y$ and $\\gcd(x,y)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} constexpr ll mod=998244353; ll binpow(ll a,int b){ ll res=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) res=res*a%mod; a=a*a%mod; } return res; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; factor; for(ll f=2;f*f\u0026lt;=n;f++){ if(n%f==0){ factor.push_back(f); while(n%f==0) n/=f; } } if(n\u0026gt;1) factor.push_back(n); array\u0026lt;ll,1000\u0026gt; fac,inv; fac[0]=inv[0]=1; for(int i=1;i\u0026lt;1000;i++) fac[i]=fac[i-1]*i%mod; inv[999]=binpow(fac[999],mod-2); for(int i=998;i\u0026gt;0;i--) inv[i]=inv[i+1]*(i+1)%mod; auto count=[\u0026amp;](ll x,ll y){ x/=y; ll ret=1,sum=0; for(auto it:factor){ int tmp=0; while(x%it==0){ tmp++; x/=it; } ret=ret*inv[tmp]%mod; sum+=tmp; } ret=ret*fac[sum]%mod; return ret; }; int q; cin\u0026gt;\u0026gt;q; while(q--){ ll x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; ll g=gcd(x,y); cout\u0026lt;\u0026lt;count(x,g)*count(y,g)%mod\u0026lt;\u0026lt;endl; } return 0; } ","date":1586563200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586563200,"objectID":"cb5d68aaebdcc382a9e65bb26a97876f","permalink":"thallium.github.io/tgc54.com/post/cf1334e/","publishdate":"2020-04-11T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1334e/","section":"post","summary":"","tags":["Math","Number Theory"],"title":"Editorial of Codeforces 1334E - Divisor Paths","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Such an elegant and amazing solution.\nSolution First we can ignore first level of blocks. Let $dp_{s,b}$ be the number of ways to put $b$ blocks on $s$ stacks(some stacks could be empty).\nNow let’s consider transition, there are three cases:\nThe first level is full The leftmost stack is empty The rightmost stack is empty For the first case we can simply ignore the first level and the number of ways is $dp_{s,b-s}$. For the second and the third case, we can ignore the empty stack and the answer is $2\\cdot dp_{s-1,b}$. However, the two cases overlap, since the scenario where both the leftmost and the rightmost stacks are empty can be reached from both cases. So we need to subtract $dp_{s-2,b}$. Overall, the formula is:\n$$dp_{s,b}=dp_{s,b-s}+2\\cdot dp_{s-1,b}+dp_{s-2,b}$$\nThis can be calculated recursively with memoization.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} const int N=5e3+5; ll dp[N][N]; const int mod=1e9+7; ll solve(int s,int b){ if(b==0) return 1; if(s\u0026lt;=0) return 0; ll\u0026amp; ret=dp[s][b]; if( ret) return ret; ret=0; if(s\u0026lt;=b) ret=solve(s,b-s); ret=(ret+solve(s-1,b)*2-solve(s-2,b)+mod)%mod; return ret; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int s,b; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;solve(s,b-s); return 0; } ","date":1586131200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586131200,"objectID":"259cdce95a7a9f8479e1be1562fd11d9","permalink":"thallium.github.io/tgc54.com/post/gym102428f/","publishdate":"2020-04-06T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/gym102428f/","section":"post","summary":"Such an elegant and amazing solution.\n","tags":["DP"],"title":"Solution for Gym 102428F - Fabricating Sculptures","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution WLOG, assume $a\\leq b\\leq c$. If we choose only one stone, the diameter of the sphere is $\\frac a 2$. If we want to choose two stones, we should find another stone whose two of its edges are $b$ and $c$, since we must expand the shortest side to get a bigger sphere. We can use a set to maintain the length of the edge and the index.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); template\u0026lt;typename... Args\u0026gt; void write(Args... args) { ((cout \u0026lt;\u0026lt; args \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); cout\u0026lt;\u0026lt;endl;} int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; ans; int best=0; map\u0026lt;pii,pii\u0026gt; mp; for1(i,n){ int a[3]; forn(i,3) cin\u0026gt;\u0026gt;a[i]; sort(a,a+3); if(a[0]\u0026gt;best){ ans={i}; best=a[0]; } if(mp.count({a[1],a[2]})){ auto p=mp[{a[1],a[2]}]; int now=min({a[1],a[2],a[0]+p.F}); if(now\u0026gt;best){ best=now; ans={i,p.S}; } } mp[{a[0],a[1]}]=max(mp[{a[0],a[1]}],{a[2],i}); mp[{a[0],a[2]}]=max(mp[{a[0],a[2]}],{a[1],i}); mp[{a[1],a[2]}]=max(mp[{a[1],a[2]}],{a[0],i}); } cout\u0026lt;\u0026lt;ans.size()\u0026lt;\u0026lt;endl; for(auto it:ans) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1585958400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1585958400,"objectID":"ab3f83a898ca514ecf184aa486117956","permalink":"thallium.github.io/tgc54.com/post/cf733d/","publishdate":"2020-04-04T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf733d/","section":"post","summary":"","tags":null,"title":"Solution for CodeForces 733D - Kostya the Sculptor","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Link\nSolution The solution combines shortest paths and 0/1 knapsack algorithms:\nFirst step is to find the cost and prestige of each dish, which is finding the shortest path on a DAG. This could be done in $O(n)$ using topological sort. Update the cost while doing topological sort:\nms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [dish,cost,prestige]:G[now]){ if(cost[now]+cost\u0026lt;cost[dish]){//choose the smallest cost cost[dish]=cost[now]+cost; pre[ }else if(cost[now]+cost==cost[dish]){//if the cost is same, choose the highest prestige pre[dish]=max(pre[dish],pre[now]+prestige); } deg[dish]--; if(deg[dish]==0) q.push(dish); } } The next part is more familiar: using 0/1 knapsack algorithm to find the answer.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) using namespace std; const int INF = 0x3f3f3f3f; const int N=1e4+5; vector\u0026lt;tuple\u0026lt;int,int,int\u0026gt;\u0026gt; G[N]; int cost[N],pre[N],deg[N],dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,b; cin\u0026gt;\u0026gt;b\u0026gt;\u0026gt;n; unordered_map\u0026lt;string,int\u0026gt; id; auto getid=[\u0026amp;](string\u0026amp; st){ if(id[st]) return id[st]; else return id[st]=size(id); }; forn(i,n){ string s,t,tmp; int x,y; cin\u0026gt;\u0026gt;s\u0026gt;\u0026gt;t\u0026gt;\u0026gt;tmp\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; int ids=getid(s),idt=getid(t); G[idt].eb(ids,x,y); deg[ids]++; } //topo sort ms(cost,INF); queue\u0026lt;int\u0026gt; q; for1(i,id.size()){ if(deg[i]==0){ q.push(i); cost[i]=0; } } while(!empty(q)){ int now=q.front(); q.pop(); for(auto [to0,to1,to2]:G[now]){ if(cost[now]+to1\u0026lt;cost[to0]){ cost[to0]=cost[now]+to1; pre[to0]=pre[now]+to2; }else if(cost[now]+to1==cost[to0]){ pre[to0]=max(pre[to0],pre[now]+to2); } deg[to0]--; if(deg[to0]==0) q.push(to0); } } //knapsack for1(i,size(id)){ for(int j=b;j\u0026gt;=cost[i];j--){ dp[j]=max(dp[j],dp[j-cost[i]]+pre[i]); } } int ans1=0,ans2=0; for(int i=0;i\u0026lt;=b;i++){ if(dp[i]\u0026gt;ans1){ ans1=dp[i]; ans2=i; } } cout\u0026lt;\u0026lt;ans1\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;ans2; return 0; } ","date":1584144e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584144e3,"objectID":"795058df00ec226b19984fa748279acb","permalink":"thallium.github.io/tgc54.com/post/swerc2017e/","publishdate":"2020-03-14T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/swerc2017e/","section":"post","summary":"","tags":["Graph Theory","Shortest Path","Topological Sort","DP","Knapsack"],"title":"Solution for SWERC2017 E - Ingredients","type":"post"},{"authors":null,"categories":["Alg Notes"],"content":"Basic usage of Policy-Based Data Structure (PB_DS)\nHash Table Usage #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; cc_hash_table\u0026lt;int, int\u0026gt; table;//collision-chaining hash table gp_hash_table\u0026lt;int, int\u0026gt; table;//probing hash table Use it like a unordered_map.\nA slightly better hash Function struct custom_hash { size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); x ^= FIXED_RANDOM; return x ^ (x \u0026gt;\u0026gt; 16); } }; Unbeatable hash function struct custom_hash { static uint64_t splitmix64(uint64_t x) { // http://xorshift.di.unimi.it/splitmix64.c x += 0x9e3779b97f4a7c15; x = (x ^ (x \u0026gt;\u0026gt; 30)) * 0xbf58476d1ce4e5b9; x = (x ^ (x \u0026gt;\u0026gt; 27)) * 0x94d049bb133111eb; return x ^ (x \u0026gt;\u0026gt; 31); } size_t operator()(uint64_t x) const { static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count(); return splitmix64(x + FIXED_RANDOM); } }; Balanced BST Declaration Header #include \u0026lt;ext/pb_ds/tree_policy.hpp\u0026gt; #include \u0026lt;ext/pb_ds/assoc_container.hpp\u0026gt; using namespace __gnu_pbds; Make a map tree\u0026lt;int, int, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a set tree\u0026lt;int, null_type, less\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Make a multi-set tree\u0026lt;pair\u0026lt;int,int\u0026gt;, null_type, less\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Alternatively, you can use std::less_equal, but lower_bound and upper_bound will swap their functionality.\ntree\u0026lt;int, null_type, less_equal\u0026lt;int\u0026gt;, rb_tree_tag, tree_order_statistics_node_update\u0026gt; t; Beyond std::set : ranking Your must use tree_order_statistics_node_update to get order statistic:\nsize_type order_of_key(key_const_reference);// returns the number of elements that are smaller than key iterator find_by_order(size_type order)// order starts from 0 Use lower_bound and upper_bound to find precursor and successor Find precursor:\n*prev(t.lower_bound(x))//set prev(t.lower_bound({x,0}))-\u0026gt;first//multi-set Find successor\n*t.upper_bound(x);//set *t.lower_bound({x+1,0}); Priority Queue Prototype template\u0026lt;typename Value_Type, typename Cmp_Fn = std::less\u0026lt;Value_Type\u0026gt;, typename Tag = pairing_heap_tag, typename Allocator = std::allocator\u0026lt;char \u0026gt; \u0026gt; class priority_queue; Usage Just use the default parameter and you will get the best performance(must include the namespace):\n#include\u0026lt;ext/pb_ds/priority_queue.hpp\u0026gt; __gnu_pbds::priority_queue\u0026lt;int\u0026gt;; All the five tags:\nbinary_heap_tag binomial_heap_tag pairing_heap_tag thin_heap_tag rc_binomial_heap_tag What’s different from std::priority_queue point_iterator push(const_reference r_val);//return a iterator after push void PB_DS_CLASS_C_DEC:: join(PB_DS_CLASS_C_DEC\u0026amp; other)//clean other after join void split(Pred prd,priority_queue \u0026amp;other) void modify(point_iterator it,const key) begin(); end();//begin and end iterator Reference Policy-Based Data Structure\nBlowing up unordered_map, and how to stop getting hacked on it\npb_ds库的一些常用方法\n用 pbds 过 luogu P3369【模板】普通平衡树\n","date":1584057600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1584057600,"objectID":"1ebae1fea5c589e737fe38ad6f61c11e","permalink":"thallium.github.io/tgc54.com/post/pbds_basic_usage/","publishdate":"2020-03-13T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/pbds_basic_usage/","section":"post","summary":"Basic usage of Policy-Based Data Structure (PB_DS)\n","tags":null,"title":"Basic Usage of PB_DS","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution The solution consists of two DFS, first DFS is to calculate $sub_i$: the max difference of the subgraph in subtree of $i$. Note that we treat the graph as a rooted tree, so the subtree means the part that is lower than node $i$. This is pretty naive DFS.\nThe second dfs is to find the answer of each vertex. Since we only considered the contribution of the subtree, we need to add the contribution of other part the graph. How to find this contribution? We always get the answer of higher nodes first. Let $v$ be the children of node $i$, if $sub_v\u0026gt;0$, the contribution is $ans_i-sub_v$ since we don’t want to count the contribution of subtree twice. If $sub_v\\leq 0$, we don’t need to subtract $sub_v$ since we didn’t count it in $ans_i$. If $ans_i-sub_v\u0026lt;0$, it’s useless for $ans_v$. Thus, the contribution of other part is $\\max(ans_i-\\max(sub_v,0),0)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; typedef long long ll; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; int ans[N],a[N],dp[N]; void dfs1(int u,int fa){ dp[u]=a[u]; for(auto it:G[u]){ if(it!=fa){ dfs1(it,u); dp[u]+=max(0,dp[it]); } } } void dfs2(int u,int fa,int pd){ ans[u]=dp[u]+pd; for(auto v:G[u]){ if(v!=fa){ dfs2(v,u,max(ans[u]-max(dp[v],0),0)); } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; for1(i,n) { cin\u0026gt;\u0026gt;a[i]; if(!a[i]) a[i]=-1; } forn(i,n-1){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } dfs1(1,-1); dfs2(1,-1,0); for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1583971200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583971200,"objectID":"020fea8600bea1234d92d645d89049dd","permalink":"thallium.github.io/tgc54.com/post/cf1324f/","publishdate":"2020-03-12T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1324f/","section":"post","summary":"","tags":["DFS","DP","Tree"],"title":"Solution for CodeForces 1324F - Maximum White Subtree","type":"post"},{"authors":null,"categories":["Solutions"],"content":"My math is sh!t.\nAdapted from the original tutorial.\nSolution First of all, there will be $n-1$ distinct elements in the array and there are $m\\choose{n-1}$ways to choose.\nNext, there are $n-2$ elements we could choose to duplicate. Finally, some elements will appear before the maximum and some will appear after. However, the duplicated elements will appear on both sides, so there are $2^{n-3}$ ways to choose their positions.\nIn summary, the answer is ${{m}\\choose{n - 1}} (n - 2)2^{n - 3}$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int mod=998244353; ll bipow(ll a,int b){ ll ans=1; for(;b;b\u0026gt;\u0026gt;=1){ if(b\u0026amp;1) ans=ans*a%mod; a=a*a%mod; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; if(n==2) return cout\u0026lt;\u0026lt;0,0; ll ans=1,r=1; for1(i,m) ans=ans*i%mod; for1(i,n-1) r=r*i%mod; for1(i,m-n+1) r=r*i%mod; ans=ans*bipow(r,mod-2)%mod*(n-2)%mod; ans=ans*bipow(2,n-3)%mod; cout\u0026lt;\u0026lt;ans; return 0; } ","date":1583798400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583798400,"objectID":"3fa273de67c3f66da4cbd758ac5d42b0","permalink":"thallium.github.io/tgc54.com/post/cf1312d/","publishdate":"2020-03-10T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1312d/","section":"post","summary":"My math is sh!t.\n","tags":["Math","Combinatorics"],"title":"Solution for CodeForces 1312D - Count the Arrays","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution First let’s use BFS to find the distance from node $1$ and node $n$ to all nodes. Let $x_i$ be the distance to node $1$ and $y_i$ be the distance to node $n$.\nNow we want to choose two nodes $a$ and $b$ such that $\\min(x_a+y_b,x_b+y_a)$ is maximized. Without losing generality, assume $x_a+y_b\\leq x_b+y_a$. That is to say we want to maximize $x_a+y_b$ subject to $x_a+y_b\\leq x_b+y_a$. So we can sort by $x_i-y_i$ and iterate over $y$ while keeping the maximum value of $x_a$ before $y_b$.\nAlso note that the answer cannot be bigger than the distance between node $1$ and $n$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define fore(i, l, r) for (int i = int(l); i \u0026lt;= int(r); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define eb emplace_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; #define all(x) (x).begin(),(x).end() #define de(x) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x)\u0026lt;\u0026lt;endl #define de2(x,y) cout\u0026lt;\u0026lt;#x\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;(x) \u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt; #y\u0026lt;\u0026lt;\u0026#34; = \u0026#34;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl; using namespace std; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; constexpr int INF = 0x3f3f3f3f; mt19937 gen(chrono::high_resolution_clock::now().time_since_epoch().count()); const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; void bfs(vector\u0026lt;int\u0026gt;\u0026amp; dis,int s){ queue\u0026lt;int\u0026gt; q; q.push(s); dis[s]=0; while(!q.empty()){ int now=q.front(); q.pop(); for(int next:G[now]){ if(dis[next]==INF){ dis[next]=dis[now]+1; q.push(next); } } } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,k; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;k; vector\u0026lt;int\u0026gt; sp(k); for(auto\u0026amp; it:sp) cin\u0026gt;\u0026gt;it; forn(i,m){ int x,y; cin\u0026gt;\u0026gt;x\u0026gt;\u0026gt;y; G[x].pb(y); G[y].pb(x); } vector\u0026lt;int\u0026gt; dis1(n+1,INF),dis2(n+1,INF); bfs(dis1,1); bfs(dis2,n); vector\u0026lt;pii\u0026gt; data(k); forn(i,k) data[i]={dis1[sp[i]]-dis2[sp[i]],sp[i]}; sort(all(data)); int best=0,mx=-INF; for(auto it:data){ int a=it.S; best=max(best,mx+dis2[a]); mx=max(mx,dis1[a]); } cout\u0026lt;\u0026lt;min(dis1[n],best+1); return 0; } ","date":1583452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583452800,"objectID":"5ca7caafc8fc8edebd563e74ef379896","permalink":"thallium.github.io/tgc54.com/post/cf1307d/","publishdate":"2020-03-06T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1307d/","section":"post","summary":"","tags":["BFS","Graph Theory"],"title":"Solution for CodeForces 1307D - Cow and Fields","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Monotone stack is such an interest stuff.\nSolution To be honest, I don’t really know how to explain the solution clearly. It’s kind of a “greedy” solution: for each tank, you try to use this to reduce the water in previous tanks. Specifically, you can see water tanks as a succession of groups, if the current group has a smaller average value than the left one, then merge them. The stack is used to store the number of tanks and the sum of water.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;it); vector\u0026lt;double\u0026gt; ans(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; st; forn(i,n){ ll sum=a[i],num=1; while(!st.empty()\u0026amp;\u0026amp;(1.0*sum/num)\u0026lt;=(1.0*st.top().F/st.top().S)){ sum+=st.top().F; num+=st.top().S; st.pop(); } st.push({sum,num}); } int cnt=n-1; while(!st.empty()){ for(int i=0;i\u0026lt;st.top().S;i++,cnt--){ ans[cnt]=1.0*st.top().F/st.top().S; } st.pop(); } for(auto it:ans) printf(\u0026#34;%.9lf\\n\u0026#34;,it); return 0; } ","date":1582934400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582934400,"objectID":"15bae960ea2bc83b6d6bff076547ff3a","permalink":"thallium.github.io/tgc54.com/post/cf1300e/","publishdate":"2020-02-29T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1300e/","section":"post","summary":"Monotone stack is such an interest stuff.\n","tags":["Data Structure","Monotonic Stack"],"title":"Solution for CodeForces 1300E - Water Balance","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Problem Link\nSolution Let the input be $A$ and the answer be $P$. $A_i-A_{i-1}$ is the number of numbers that are greater than $P_i$, so we can also know the how many numbers are smaller than $P_i$. Now we build a segment tree which counts the occurrence of numbers in $1\\dots n$ and iterate $A$ reversely, we could know how many unused numbers are smaller than $P_i$ and then find the corresponding number in the segtree and decrease the occurrence of that number by one.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) using namespace std; const int N=5e4+5; int sum[N\u0026lt;\u0026lt;2]; void build(int k,int l,int r){ sum[k]=r-l+1; if(l==r) return; int mid=(l+r)\u0026gt;\u0026gt;1; build(k\u0026lt;\u0026lt;1,l,mid); build(k\u0026lt;\u0026lt;1|1,mid+1,r); } int query(int root,int l,int r,int p){ sum[root]--; if(l==r) return l; int mid=(l+r)\u0026gt;\u0026gt;1; if(sum[root\u0026lt;\u0026lt;1]\u0026gt;=p) return query(root\u0026lt;\u0026lt;1,l,mid,p); else return query(root\u0026lt;\u0026lt;1|1,mid+1,r,p-sum[root\u0026lt;\u0026lt;1]); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1),ans(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; build(1,1,n); for(int i=n;i\u0026gt;0;i--){ int p=a[i]-a[i-1]; p=i-p; ans[i]=query(1,1,n,p); } for1(i,n) cout\u0026lt;\u0026lt;ans[i]\u0026lt;\u0026lt;(i==n?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } ","date":1582934400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582934400,"objectID":"8fb8ef07b817fa60c36dc300c30fa881","permalink":"thallium.github.io/tgc54.com/post/hdu5592/","publishdate":"2020-02-29T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/hdu5592/","section":"post","summary":"","tags":["Data Structure","Segment Tree"],"title":"Solution for HDU 5592 - ZYB's Premutation","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Problem link\nTranslation Given a sequence $a$ of length $n$ and $q$ queries in format $l,r,x$, find $\\max\\limits_{l\\leq i\\leq r}\\gcd(x,a_i)$.\nSolution Since $a_i$ is rather small, we can precalculate all the factors of all the numbers smaller than $1e5$. Then, for each factor, we store all the $i$ such that $a_i$ contains this factor in ascending order.\nFor each query, we iterate all the factors from biggest to smallest and see if we can find some number in $[l,r]$ that contains this factor. We could use binary search to achieve this.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define for1(i, n) for (int i = 1; i \u0026lt;= int(n); ++i) #define pb push_back using namespace std; const int N=1e5+5; vector\u0026lt;int\u0026gt; p[N],fac[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n,q; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;q; for1(i,1e5){ for(int j=i;j\u0026lt;=1e5;j+=i) fac[j].pb(i); } for1(i,n){ int x; cin\u0026gt;\u0026gt;x; for(auto f:fac[x]) p[f].pb(i); } while(q--){ int l,r,x; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r\u0026gt;\u0026gt;x; for(int i=fac[x].size()-1;i\u0026gt;=0;i--){ int f=fac[x][i]; if(p[f].empty()) continue; auto it=lower_bound(p[f].begin(),p[f].end(),l); if(it!=p[f].end()\u0026amp;\u0026amp;*it\u0026lt;=r){ cout\u0026lt;\u0026lt;f\u0026lt;\u0026lt;endl; break; } } } return 0; } ","date":1582848e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582848e3,"objectID":"c6bc86bc7f5e1a0a0a21e7b97150bc53","permalink":"thallium.github.io/tgc54.com/post/nc4090e/","publishdate":"2020-02-28T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/nc4090e/","section":"post","summary":"Problem link\n","tags":["Math"],"title":"Solution for NewCoder 4090E - 最大GCD(max GCD)","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Time to learn monotone stack.\nSolution It’s quite obvious that the answer goes non-decreasing from the start and at some point turns to non-increasing. We want to find the optimal turning point.\nWe can build two arrays $pre$ and $suf$ of length n. The ith element of $pre$ represents the maximum sum of floors from 1 to i if the floors are non-decreasing. Similar definition for $suf$. The turning point t is where $pre_t+suf_t-m_t$ is maximum.\nFor example: let $m={1,2,3,2,1}$\n0 1 2 3 4 pre 1 3 6 7 5 suf 5 7 6 3 1 m 1 2 3 2 1 pre+suf-m 5 8 9 8 5 We can build the arrays by maintaining a mono-increasing stack stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; to find the rightest number smaller than m_i. The second element is the number of floors and first element is the number of buildings with the same height. You will understand it better in the detailed buildings process of $pre$:\ni=0\nnothing in the stack.\npre[0]+=1\nPush{1,1} to the stack and now the stack:{{1,1}}\ni=1\nFirst set pre[1]=pre[0]\nSince m[1]\u0026gt;stack.top().second, no pop.\npre[1]+=m[1]\nnow $pre_1=3$\nPush {1,2} to the stack and the stack is now:{{1,1},{1,2}}\ni=2\nSimilar to i=1.\npre[2]=6\n{{1,1},{1,2},{1,3}}\ni=3\nm[3]\u0026lt;stack.top().second which means that we need to change the height of previous buildings to keep the monotonicity. Keep popping out the bigger element and {1,3} is popped. The pre[3] should be decreased by 1*3 and is 3 now. Then the height of 2,3 should be 2 and pre[3]+=2*2. Finally we push {2,2} to the stack.\ni=4\nSimilarly, we pop out {2,2} and {1,2} and pre[4]-=2*2+1*2 and now pre[4]=1. Then the height of 1,2,3,4 should be 1 and pre[4]+=4*1. Finally push {4,1} to the stack.\nWe could build $suf$ in the similar way but go from right to left.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define ford(i, n) for (int i = int(n)-1; i \u0026gt;= 0; --i) #define F first #define S second using namespace std; typedef long long ll; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;ll\u0026gt; a(n); for(auto\u0026amp; it:a) cin\u0026gt;\u0026gt;it; vector\u0026lt;ll\u0026gt; pre(n),suf(n); stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt; stk; forn(i,n){ int now=1; if(i) pre[i]=pre[i-1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; pre[i]-=stk.top().F*stk.top().S; stk.pop(); } pre[i]+=a[i]*now; stk.push({now,a[i]}); } stk=stack\u0026lt;pair\u0026lt;ll,ll\u0026gt;\u0026gt;(); ford(i,n){ int now=1; if(i!=n-1) suf[i]=suf[i+1]; while(!stk.empty()\u0026amp;\u0026amp;stk.top().S\u0026gt;a[i]){ now+=stk.top().F; suf[i]-=stk.top().F*stk.top().S; stk.pop(); } suf[i]+=a[i]*now; stk.push({now,a[i]}); } ll mx=0,pos; forn(i,n){ if(pre[i]+suf[i]-a[i]\u0026gt;mx){ mx=pre[i]+suf[i]-a[i]; pos=i; } } for(int i=pos-1;i\u0026gt;=0;i--){ a[i]=min(a[i+1],a[i]); } for(int i=pos+1;i\u0026lt;n;i++) a[i]=min(a[i-1],a[i]); for(auto it:a) cout\u0026lt;\u0026lt;it\u0026lt;\u0026lt;\u0026#39; \u0026#39;; return 0; } ","date":1582588800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582588800,"objectID":"69da53fcd077d78c674e00512f4bb95d","permalink":"thallium.github.io/tgc54.com/post/cf1313c2/","publishdate":"2020-02-25T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1313c2/","section":"post","summary":"Time to learn monotone stack.\n","tags":["Data Structure","Monotonic Stack"],"title":"Solution for CodeForces 1313C2 - Skyscrapers (hard version)","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution In this problem, we could use DFS with memorization, the state is the following four elements: the number of left piles, the top cards on the three rightmost piles. If we could have one pile in the end, the answer is yes. BFS also works for this problem using the same state which might be more intuitive.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int N=60; string s[N]; int dp[N][N][N][N]; bool dfs(int n,int i,int j,int k){ if(n==0) return true; int\u0026amp; d=dp[n][i][j][k]; if(dp[n][i][j][k]) return dp[n][i][j][k]==1?true:false; if(s[i][0]==s[j][0]||s[i][1]==s[j][1]){ if(dfs(n-1,i,k,n-3)){ return d=1; } } if(n\u0026gt;=3\u0026amp;\u0026amp;(s[i][0]==s[n-3][0]||s[i][1]==s[n-3][1])){ if(dfs(n-1,j,k,i)){ return d=1; } } d=-1; return false; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; forn(i,n) cin\u0026gt;\u0026gt;s[i]; cout\u0026lt;\u0026lt;(dfs(n-1,n-1,n-2,n-3)?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } ","date":1582329600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582329600,"objectID":"b5684ece9bae68b99c24c428d83b71cd","permalink":"thallium.github.io/tgc54.com/post/cf208b/","publishdate":"2020-02-22T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf208b/","section":"post","summary":"","tags":["DFS","DP"],"title":"Solution for Codeforces 208B - Solitaire","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution It’s kinda obvious that we need to write a function $F(x)$ which solves the problem $1\\dots x$ and the answer will be $F(r)-F(l-1)$.\nOne tricky way to write $F(x)$ is that we can get the required number by appending the first digit to the end of an arbitrary number. If x is less than 10, the answer is x, otherwise the answer is x without last digit (divide x by 10) plus 9. What’s more, if the last digit is smaller than the first digit we have to decrease the answer by 1.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll cal(ll x){ if(x\u0026lt;10) return x; string st=to_string(x); ll ans=9; if(st[0]\u0026gt;st.back()) ans--; ans+=x/10; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll l,r; cin\u0026gt;\u0026gt;l\u0026gt;\u0026gt;r; cout\u0026lt;\u0026lt;cal(r)-cal(l-1); return 0; } ","date":1582243200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582243200,"objectID":"004b8d883b0b02a59fb7c008879f4e7b","permalink":"thallium.github.io/tgc54.com/post/cf205c/","publishdate":"2020-02-21T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf205c/","section":"post","summary":"","tags":["Math","Combinatorics"],"title":"Solution for Codeforces 205D - Little Elephant and Interval","type":"post"},{"authors":null,"categories":["Alg Notes"],"content":"vector\u0026lt;int\u0026gt; G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } ","date":1582070400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1582070400,"objectID":"14eafa60d96b3c7a8a3764baeaa1018e","permalink":"thallium.github.io/tgc54.com/post/longestpathondag/","publishdate":"2020-02-19T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/longestpathondag/","section":"post","summary":"vector\u003cint\u003e G[N]; int dp[N]; int get(int u){ if(dp[u]) return dp[u]; for(auto it:G[u]){ dp[u]=max(dp[u],get(it)+1); } return dp[u]; } ","tags":["Graph Theory","DP","DFS"],"title":"Finding the longest path on a DAG","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Learned a lot.\nIn this blog I would like to put emphasis on what I learned from other’s implementation. The idea is quite simple: for every edge E find the maximum number that appears in the paths that contain E and set that number for E, then check if there’s a contradiction. However, the implementation seems to be not easy.\nI want to talk about two techniques in this code.\nThe first one is how to find the index of the edge that we are visiting.\nInstead of using map\u0026lt;pair\u0026lt;int,int\u0026gt;,int\u0026gt; the author uses the lower vertex of each edge to denote that edge and label them when doing the DFS. This reduces both time and space complexity.\nThe second one is how to find the path between two vertices.\nIn a rooted tree, we can find the path by finding the LCA of the two vertices. The algorithm is quite naive: jump up over and over until the two vertices meet. The author uses very short codes to achieve this:\nwhile (u != v) { if (dep[u] \u0026lt; dep[v]) swap(u, v); //do something... u = fa[u]; } Overall, the question is good and what I learned is also amazing which I think is worth writing a blog.\n","date":1580860800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580860800,"objectID":"5729bc5035fb1283230001e1a31b5013","permalink":"thallium.github.io/tgc54.com/post/cf1296f/","publishdate":"2020-02-05T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1296f/","section":"post","summary":"Learned a lot.\n","tags":["DFS","Tree"],"title":"Solution for CodeForces 1296F - Berland Beauty and what I learned","type":"post"},{"authors":null,"categories":["Solutions"],"content":"FML\nSolution Let $g= \\gcd(a,m)$, so we have $a=g\\cdot k, m=g\\cdot l,\\gcd(l,k)=1$,first observation is that if we want $\\gcd(a,m)=\\gcd(a+x,m)$, $x$ has to be a multiple of $g$, let $x=n\\cdot g$. Furthermore, $k+n$ and $l$ have to be coprime, so we need to find how many numbers ranging from $k$ to $k+l$ are coprime with $l$. For numbers bigger than $l$, if $\\gcd(k+x,l)=1$, then $\\gcd((k+x)\\bmod l,l)=1$. Since $(k+x)\\bmod l\u0026lt; l$, what we actually need to find is the number of numbers that are coprime with $l$ and smaller than $l$, i.e. $\\varphi(l)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; ll Phi(ll m){ ll ans=m; for(ll i=2;i*i\u0026lt;=m;i++){ if(m%i==0){ ans-=ans/i; while(m%i==0) m/=i; } } if(m\u0026gt;1) ans-=ans/m; return ans; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int tt; cin\u0026gt;\u0026gt;tt; while(tt--){ ll a,m; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;m; cout\u0026lt;\u0026lt;Phi(m/gcd(a,m))\u0026lt;\u0026lt;endl; } return 0; } ","date":1580256e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1580256e3,"objectID":"5b6c62af14c2d3a52fc331307d3dad86","permalink":"thallium.github.io/tgc54.com/post/cf1295d/","publishdate":"2020-01-29T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1295d/","section":"post","summary":"FML\n","tags":["Math","Euler's totient function","Number Theory"],"title":"Solution for CodeForces 1295D - Same GCDs","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Tutorial By adding $x$ or subtracting $x$, we can obtain any number in the same residue class so we only care about $a_i\\bmod x$. To maximize the mex, we need to obtain consecutive numbers starting from 0 as many as possible. In the perspective of modular, that means we need $1,2,3,4,\\dots,x,1,2,3,4,\\dots,x,\\dots$. Therefore, we should store the size of each residue class and try to increase the answer when we have a new number.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q,x; cin\u0026gt;\u0026gt;q\u0026gt;\u0026gt;x; vector\u0026lt;int\u0026gt; cnt(x); int ans=0; while(q--){ int n; cin\u0026gt;\u0026gt;n; cnt[n%x]++; while(cnt[ans%x]){ cnt[ans%x]--; ans++; } cout\u0026lt;\u0026lt;ans\u0026lt;\u0026lt;endl; } return 0; } ","date":1579651200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579651200,"objectID":"a10e14412f70ac1c2806d7683162d4b6","permalink":"thallium.github.io/tgc54.com/post/cf1294d/","publishdate":"2020-01-22T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1294d/","section":"post","summary":"","tags":["Math"],"title":"Solution for CodeForces 1294D - MEX maximizing","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Solution It’s quite obvious that $a$ and $b$ must be coprime. Now let’s prime factorize $X$ and there will be at most 11 distinct primes since the product of the first 12 primes is greater than $1\\cdot 10^{12}$. To find the answer we can simply distribute them between $a$ and $b$ with bruteforce.\nAnother solution is loop over all divisors $d$ of $X$, check if $\\gcd(d,\\frac X d)$ is 1 and minimize the answer.\nCode Prime factorization:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; int(n); ++i) #define pb push_back using namespace std; typedef long long ll; const ll INF = 1e12; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; vector\u0026lt;ll\u0026gt; vec; for(ll f=2;f*f\u0026lt;=x;f++){ ll tmp=1; while(x%f==0){ tmp*=f; x/=f; } if(tmp!=1) vec.pb(tmp); } if(x\u0026gt;1)vec.pb(x); ll aa=INF,ab=INF; for(ll i=0;i\u0026lt;(1\u0026lt;\u0026lt;vec.size());i++){ ll a=1,b=1; forn(j,vec.size()){ if((i\u0026amp;(1\u0026lt;\u0026lt;j))\u0026gt;0) a*=vec[j]; else b*=vec[j]; } if(max(a,b)\u0026lt;max(aa,ab)){ aa=a; ab=b; } } cout\u0026lt;\u0026lt;ab\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;aa; return 0; } Looping factors:\n#include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const ll INF=1e15; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); ll x; cin\u0026gt;\u0026gt;x; ll ansa=INF,ansb=INF; for(ll f=1;f*f\u0026lt;=x;f++){ if(x%f==0){ if(__gcd(f,x/f)==1){ if(x/f\u0026lt;ansb){ ansa=f; ansb=x/f; } } } } cout\u0026lt;\u0026lt;ansa\u0026lt;\u0026lt;\u0026#39; \u0026#39;\u0026lt;\u0026lt;ansb; return 0; } ","date":1578614400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578614400,"objectID":"717769c0b8ad73c44465a3598af7f991","permalink":"thallium.github.io/tgc54.com/post/cf1285c/","publishdate":"2020-01-10T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1285c/","section":"post","summary":"","tags":["Math","Number Theory"],"title":"Solution for Codeforces 1285C - Fadi and LCM","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Almost\nSolution Let’s start with the highest bit since it’s the most significant. We need to divide elements into two groups, one with elements which is $1$ on this bit and the other with elements which is $0$ on this bit. If either group is empty, we can always assign 0 or 1 to this bit to make this bit 0 in the answer and we can just proceed to the next bit, otherwise this bit is always 1. In order to know which value to assign we will solve the same problem recursively for each of the groups for the next bit. Let the answer for the two groups be $ans_1$ and $ans_0$ and the current bit is $i$ the answer would be $2^i+\\min(ans_1,ans_0)$.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; vector\u0026lt;int\u0026gt; a; int dfs(vector\u0026lt;int\u0026gt; v,int idx){ if(v.empty()) return 0; if(idx==-1) return 0; vector\u0026lt;int\u0026gt; a,b; for(auto it:v){ if(it\u0026amp;(1\u0026lt;\u0026lt;idx)) a.pb(it); else b.pb(it); } if(a.empty()) return dfs(b,idx-1); if(b.empty()) return dfs(a,idx-1); return min(dfs(a,idx-1),dfs(b,idx-1))+(1\u0026lt;\u0026lt;idx); } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin\u0026gt;\u0026gt;n; a.resize(n); for(int\u0026amp; it:a) cin\u0026gt;\u0026gt;it; cout\u0026lt;\u0026lt;dfs(a,30); return 0; } ","date":1578614400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578614400,"objectID":"27e7e6e2f18acd2a29738fc3aebace78","permalink":"thallium.github.io/tgc54.com/post/cf1285d/","publishdate":"2020-01-10T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf1285d/","section":"post","summary":"Almost\n","tags":["Constructive Algorithm","Divide and Conquer"],"title":"Solution for Codeforces 1285D - Dr. Evil Underscores","type":"post"},{"authors":null,"categories":["Solutions"],"content":"Good DFS problem.\nSolution We need to calculate $sum_v$(sum of all the numbers in the subtree of vertex $v$) and $m1_v$ and $m2_v$ (the maximum and second maximum from all $sum$ in the subtree of vertex $v$ except $v$). Update answer after calculating $m1_v$ and $m2_v$ for each vertex. This can be done using one DFS, refer to my code for the detailed implementation.\nCode #include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define F first #define S second #define endl \u0026#39;\\n\u0026#39; using namespace std; typedef long long ll; const ll INF = 1e18+1; typedef pair\u0026lt;int, int\u0026gt; pii; const int N=2e5+5; vector\u0026lt;int\u0026gt; G[N]; ll a[N],sum[N],mx[N]; ll ans=-INF; void dfs1(int v,int p){ sum[v]=a[v]; mx[v]=-INF; ll m1=-INF,m2=-INF; for(auto it:G[v]){ if(it==p) continue; dfs1(it,v); sum[v]+=sum[it]; mx[v]=max(mx[v],mx[it]); ll val=mx[it]; if(val\u0026gt;m1) swap(m1,val); if(val\u0026gt;m2) swap(m2,val); } if(m2\u0026gt; -INF) ans=max(ans,m1+m2); mx[v]=max(mx[v],sum[v]); return; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; for1(i,n){ cin\u0026gt;\u0026gt;a[i]; } forn(i,n-1){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; G[u].emplace_back(v); G[v].emplace_back(u); } dfs1(1,1); if(ans==-INF) cout\u0026lt;\u0026lt;\u0026#34;Impossible\u0026#34;; else cout\u0026lt;\u0026lt;ans; return 0; } ","date":1576972800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1576972800,"objectID":"1afe97ca3fe8b4e9ee3575b542952749","permalink":"thallium.github.io/tgc54.com/post/cf743d/","publishdate":"2019-12-22T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cf743d/","section":"post","summary":"Good DFS problem.\n","tags":["DFS","DP"],"title":"Solution for Codeforces 743D - Chloe and pleasant prizes","type":"post"},{"authors":null,"categories":["Miscellany"],"content":"Klee’s Algorithm origin\nint length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); vector\u0026lt;pair\u0026lt;int, bool\u0026gt;\u0026gt; x(n*2); for (int i = 0; i \u0026lt; n; i++) { x[i*2] = {a[i].first, false}; x[i*2+1] = {a[i].second, true}; } sort(x.begin(), x.end()); int result = 0; int c = 0; for (int i = 0; i \u0026lt; n * 2; i++) { if (i \u0026gt; 0 \u0026amp;\u0026amp; x[i].first \u0026gt; x[i-1].first \u0026amp;\u0026amp; c \u0026gt; 0) result += x[i].first - x[i-1].first; if (x[i].second) c--; else c++; } return result; } One algorithm that I learnt from other’s code int length_union(const vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; \u0026amp;a) { int n = a.size(); sort(a.begin(), a.end()); int result = 0; int rr = 0; for(pii it:a){ int l=it.fist,r=it.second; result+=max(0,r-max(rr,l)); rr=max(rr,r); } return result; } ","date":1575072e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1575072e3,"objectID":"c3ad7fdc065ec526a6731e5e3230f5d6","permalink":"thallium.github.io/tgc54.com/post/segunion/","publishdate":"2019-11-30T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/segunion/","section":"post","summary":"","tags":["Misc"],"title":"Two Ways to Do Segment Union","type":"post"},{"authors":null,"categories":["Alg Notes"],"content":"Just as a reminder with simple explanatin.\nPath Reconstruction Use vector\u0026lt;int\u0026gt; pre[N] to record the previous vertices of all the vertices in the shortest path(s). When updating the distance to vetex $v$, if the current distance is better, discard the previous record and let the current vetex be the previous vetex of $v$. If the distance is the same, just add the current vertex to pre[v].\nfor(pii it:E[u]){ ll v=it.S,cost=it.F; if(!vis[v]\u0026amp;\u0026amp;dis[v]\u0026gt;dis[u]+cost){ dis[v]=dis[u]+cost; pre[v].clear(); pre[v].pb({cost,u}); q.push({dis[v],v}); }else if(dis[v]==dis[u]+cost) pre[v].pb({cost,u}); } Number of shortest pathes Similar to recording the path, if the distance is better then let the number be one. If the same, plus 1.\nif(!vis[v]\u0026amp;\u0026amp;dis[u]+cost\u0026lt;dis[v]){ cnt[v]=1; dis[v]=dis[u]+cost; }else if(dis[u]+cost==dis[v]){ cnt[v]++; } ","date":1573344e3,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1573344e3,"objectID":"29d9afacece5d1037490c067c88c9a16","permalink":"thallium.github.io/tgc54.com/post/dijkextention/","publishdate":"2019-11-10T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/dijkextention/","section":"post","summary":"Just as a reminder with simple explanatin.\n","tags":["Shortest Path","Graph Theory"],"title":"Extension of Dijkstra","type":"post"},{"authors":null,"categories":["Solutions"],"content":"problem link\nTo solve this problem, we need to count for each prime factors, how many intervals include them.\nFirst, let’s assume that all factors are distinct i.e. all factors only appears at one position. In this case, it’s easy to count the intervals that include them. For all primes at $p$, there are $p\\cdot(n-p+1)$ intervals including them.\nHowever, one prime can appear multiple times so we need to substract the repeated intervals(interval contain the current position and last position). Formally, if a prime appears at $p$ and lastly appears at $q$, it adds $(n-p+1)\\cdot q$ to answer.\nSo our strategy is calculating all primes less than 1e6 first. Go through all the numbers and find their prime factors. Record the all appearance of each factor and calculate their contributions to the answer.\ncode:\n#include \u0026lt;bits/stdc++.h\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; const int MAXN=1e6+5; int pri[MAXN],vis[MAXN],cnt=0; vector\u0026lt;int\u0026gt; pos[MAXN]; void init() { for (int i = 2; i \u0026lt; MAXN; ++i) { if (!vis[i]) pri[cnt++] = i; for (int j = 0; j \u0026lt;cnt; ++j) { if (1ll * i * pri[j] \u0026gt;= MAXN) break; vis[i * pri[j]] = 1; if (i % pri[j]==0) break; } } forn(i,cnt) pos[pri[i]].pb(0); } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin\u0026gt;\u0026gt;n; vector\u0026lt;int\u0026gt; a(n+1); for1(i,n) cin\u0026gt;\u0026gt;a[i]; init(); for1(i,n){ for(int j=0;pri[j]*pri[j]\u0026lt;=a[i];j++){ if(a[i]%pri[j]==0){ pos[pri[j]].pb(i); while(a[i]%pri[j]==0) a[i]/=pri[j]; } } if(a[i]\u0026gt;1) pos[a[i]].pb(i); } ll ans=0; forn(i,cnt){ for(int j=1;j\u0026lt;pos[pri[i]].size();j++) ans+=ll(pos[pri[i]][j]-pos[pri[i]][j-1])*(n-pos[pri[i]][j]+1); }\tcout\u0026lt;\u0026lt;ans; return 0; } ","date":1572566400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1572566400,"objectID":"d665bdde5cac6ea6591ceb464f80d58f","permalink":"thallium.github.io/tgc54.com/post/gym101981j/","publishdate":"2019-11-01T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/gym101981j/","section":"post","summary":"","tags":["Math"],"title":"Solution for Gym101981J  - Prime Game","type":"post"},{"authors":null,"categories":["Misc"],"content":"task.json\n{ \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } } ] } launch.json\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;C++ Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;externalConsole\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task\u0026#34;, \u0026#34;windows\u0026#34;: { \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;replace this with your gdb path\u0026#34; } } ] } ","date":1571097600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571097600,"objectID":"5718e2920ab53d1f939ca52db50407b6","permalink":"thallium.github.io/tgc54.com/post/debugconfig/","publishdate":"2019-10-15T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/debugconfig/","section":"post","summary":"","tags":["VSCode"],"title":"VSCode C++ debug configurations","type":"post"},{"authors":null,"categories":["Training Solutions"],"content":"Link\nA - Watching TV Gym - 101498A Use a map\u0026lt;int,int\u0026gt; to count the number of channels in each frequency. Iterate the map to find the frequency that displays the largest number of channels.\nB - Longest Prefix Gym - 101498B Swapping any two letters means that you can rearrange the second string so just count the number of each character in the second string and then iterate the first string to see if you can put the same in each position. When you stops, that’s the longest prefix.\nC - Lunch Break Gym - 101498C Just output which one is the smallest among the three numbers\nD - Counting Paths Gym - 101498D The first direction can be chosen arbitrarily. In the rest $a-1$ nodes we need to choose $b$ nodes where to change the direction so the answer is $\\dbinom{a-1}{b}\\pmod {10^9+7}$. As the $a$ and $b$ are large so we need to precalculate $n!\\pmod {10^9+7}$ and $(n!)^{-1}\\pmod {10^9+7}$ .\nE - Car Factory Gym - 101498E By drawing some sketchs you can find the answer is $n+k-1$.\nH - Palindrome Number Start from the first digit and try to fill every digits with the largest number. If the sum is less than $s$ or there is leading zero, the answer is -1 otherwise output the constructed number.\nI - Rock Piles Gym - 101498I At first I counldn’t find any pattern so I decided to get the sg function using brute force. Here is the pattern: only when both $N$ and $M$ are even the answer is “abdullah” otherwise the answer is hasan.\nJ - Split the String Gym - 101498J Enumerate all the possible disstance between two splitting point and check if all the splitting points are space. If you could find such a distance the answer is “YES” and vise versa.\n","date":1571011200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571011200,"objectID":"c14e4b74637c49e9214ea82be36bd490","permalink":"thallium.github.io/tgc54.com/post/cugb8/","publishdate":"2019-10-14T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/cugb8/","section":"post","summary":"Link\n","tags":["CUGBACM"],"title":"Solution for CUGBACM Training","type":"post"},{"authors":null,"categories":["Alg Notes"],"content":"What is Modular Multiplicative Inverse? If $a\\cdot x \\equiv 1\\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse.\nThe use of Inverse The inverse is used when calculating the modulo of division. $$\\dfrac{a}{b} \\equiv a \\cdot b^{-1}\\pmod p$$\nThe ways to calculate the inverse of a number The Extended Euclidean algorithm We can rewrite $a\\cdot x \\equiv 1\\pmod p$ as $a\\cdot x +p\\cdot k\\equiv \\gcd(p,a)\\pmod p$ which can be solved using the Extended Euclidean algorithm.\nvoid exgcd(int a, int b, int\u0026amp; x, int\u0026amp; y) { if (b == 0) { x = 1, y = 0; return; } exgcd(b, a % b, y, x); y -= a / b * x; } The Fermat’s Little Theorem According to Fermat’s Little Theorem $a^{p-1} \\equiv 1\\pmod p$, thus $a\\cdot x \\equiv a^{p-1}\\pmod p$, $x \\equiv a^{p-2}\\pmod p$. We can calculate it using Exponentiation by squaring.\ninline int qpow(long long a, int b) { int ans = 1; a = (a % p + p) % p; for (; b; b \u0026gt;\u0026gt;= 1) { if (b \u0026amp; 1) ans = (a * ans) % p; a = (a * a) % p; } return ans; } Calculate consecutive inverses in linear time inv[1] = 1; for (int i = 2; i \u0026lt;= n; ++i) inv[i] = (long long)(p - p / i) * inv[p % i] % p; Modulo of Combinations Calculate $\\dbinom{n}{m} \\bmod p$\nWhen n and m are not too big We can use the inverse to calculate $\\dfrac{n!}{m!\\cdot (n-m)!}\\equiv(n!\\mod p\\cdot (m!\\mod p)^{-1}\\cdot ((n-m)!\\mod p)^{-1})\\pmod p$\nCalculate the inverse of factorial $$\\because n!\\cdot(n!)^{-1}\\equiv 1 \\pmod p\\ \\therefore (n-1)!\\cdot (n\\cdot (n!)^{-1})\\equiv 1 \\pmod p$$\nTherefore$(n\\cdot (n!)^{-1})$is an inverse of $(n-1)!$.\nfact[0] = 1; for (int i = 1; i \u0026lt; maxn; i++) { fact[i] = fact[i - 1] * i %mod; } inv[maxn - 1] = power(fact[maxn - 1], mod - 2); for (int i = maxn - 2; i \u0026gt;= 0; i--) { inv[i] = inv[i + 1] * (i + 1) %mod; } When n and m are really big but p is not too big $$\\binom{n}{m}\\bmod p=\\binom{\\lfloor\\frac{n}{p}\\rfloor }{\\lfloor\\frac{m}{p}\\rfloor }\\binom{n\\bmod p }{m\\bmod p}\\bmod p$$\nlong long Lucas(long long n, long long m, long long p) { if (m == 0) return 1; return (C(n % p, m % p, p) * Lucas(n / p, m / p, p)) % p; } ","date":1570924800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570924800,"objectID":"3d93e84d605c61c34157e181d93e78f1","permalink":"thallium.github.io/tgc54.com/post/modular_mul_inverse/","publishdate":"2019-10-13T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/modular_mul_inverse/","section":"post","summary":"What is Modular Multiplicative Inverse? If $a\\cdot x \\equiv 1\\pmod p$, $x$ is called a inverse of a(modulo p), referred to as $a^{-1}$. We usually use the minimum positive inverse.\n","tags":["Math","Number Theory","Modular Inverse","Combinatorics"],"title":"Algorithm note: Modular Multiplicative Inverse and Modulo of Combinations","type":"post"},{"authors":null,"categories":["Solutions"],"content":"My first blog in English!\nSolution link to the problem\nI learnt Tarjan’s algorithm in this video. Very good visualization.\nFirst we find all the strongly conncted components in the given relationship graph. All the vetices in the same component can be treated as one point in the graph so we could get a DAG. The cows which is considered popular by all other cows are cows in the SCC with 0 out-degree. If there are more than one SCCs with 0 out-degree the answer is 0, otherwise the anser the number of cows in that SCC.\nSome details in the implementation:\nI used the $low$ value as the id of each vetices so all the vertices in the same SCC can be seen as one point.\n$low$ values are now consecutive so when you encounter one $low$ value with 0 out-degree, you have to change its out-degree to a none-zero value in case you count it again.\nCode #include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;cstring\u0026gt; #define forn(i, n) for (int i = 0; i \u0026lt; (int)(n); ++i) #define for1(i, n) for (int i = 1; i \u0026lt;= (int)(n); ++i) #define fore(i, l, r) for (int i = (int)(l); i \u0026lt;= (int)(r); ++i) #define ford(i, n) for (int i = (int)(n)-1; i \u0026gt;= 0; --i) #define pb push_back #define ms(a, x) memset(a, x, sizeof(a)) #define endl \u0026#39;\\n\u0026#39; using namespace std; const int INF = 0x3f3f3f3f; typedef long long ll; typedef pair\u0026lt;int, int\u0026gt; pii; int n,m; const int N=1e4+5; vector\u0026lt;int\u0026gt; vec[N]; int id=1; int ids[N],low[N]; bool onstack[N]; int stk[N],top=-1; int out[N]; void dfs(int x){ stk[++top]=x; onstack[x]=1; ids[x]=low[x]=id++; forn(i,vec[x].size()){ int to=vec[x][i]; if(ids[to]==-1) dfs(to); if(onstack[to]) low[x]=min(low[to],low[x]); } if(ids[x]==low[x]){ while(top\u0026gt;-1){ int node=stk[top--]; onstack[node]=0; low[node]=ids[x]; if(node==x) break; } } } void tarjan(){ for1(i,n) ids[i]=-1; for1(i,n){ if(ids[i]==-1) dfs(i); } } int main(){ ios::sync_with_stdio(false); cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; forn(i,m){ int u,v; cin\u0026gt;\u0026gt;u\u0026gt;\u0026gt;v; vec[u].pb(v); } tarjan(); for1(i,n){ forn(j,vec[i].size()){ int it=vec[i][j]; if(low[it]!=low[i]) out[low[i]]++; } } int cnt=0; int p; for1(i,n) if(out[low[i]]==0) { out[low[i]]=1; cnt++; p=low[i]; } if(cnt==1){ int ans=0; for1(i,n) if(low[i]==p) ans++; cout\u0026lt;\u0026lt;ans; }else cout\u0026lt;\u0026lt;0; return 0; } ","date":1570838400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1570838400,"objectID":"bf777e8201d838ff6f81b635a2865f89","permalink":"thallium.github.io/tgc54.com/post/poj2186/","publishdate":"2019-10-12T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/post/poj2186/","section":"post","summary":"My first blog in English!\n","tags":["Graph Theory","Strongly Connected Components"],"title":"Solution for POJ 2186 - Popular Cows","type":"post"},{"authors":null,"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"9a6cb9348361050ffbcc0117246adb56","permalink":"thallium.github.io/tgc54.com/tag/","publishdate":"2019-01-01T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/tag/","section":"","summary":"Tags","tags":null,"title":"Tags","type":"widget_page"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"132307db5be65259d13c54046ba169ea","permalink":"thallium.github.io/tgc54.com/project/cf-plot/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"thallium.github.io/tgc54.com/project/cf-plot/","section":"project","summary":"Get current ratings and plot rating changes of Codeforces with graph.js. Built with React.js.","tags":null,"title":"cf-plot","type":"project"}]